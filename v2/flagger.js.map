{"version":3,"file":"flagger.js","sources":["src/logger.js","src/object.js","src/population.js","src/stat.js","src/flag.js","src/environment.js","src/lru.js","src/router.js","src/airship.js","src/transformers/core_transformer.js","src/core.js","src/index.js","src/index-umd.js"],"sourcesContent":["export let logger = x => {\n  // eslint-disable-next-line no-console\n  console.error(x)\n}\n\nexport function setLogger(fn) {\n  logger = fn\n}\n","import md5 from 'md5'\nimport {logger} from './logger'\nimport stringify from 'fast-json-stable-stringify'\n\n\nconst validate = () => {\n  return true\n}\n\nexport const DEFAULT_ENTITY_TYPE = 'User'\n\nexport default class AirshipObject {\n  constructor(obj) {\n    let isValid = AirshipObject.isValidObject(obj)\n\n    if (!isValid) {\n      this.object = null\n      return\n    }\n\n    obj = AirshipObject._cloneObject(obj)\n    isValid = AirshipObject._fillInFields(obj)\n\n    if (!isValid) {\n      this.object = null\n      return\n    }\n\n    this.object = obj\n  }\n\n  static isValidObject(obj) {\n    let isValid = validate(obj)\n    if (!isValid) {\n      logger(validate.errors.map(e => e.message))\n    }\n\n    if (isValid) {\n      const isGroup = obj.isGroup !== undefined ? obj.isGroup : false\n      const type = obj.type !== undefined ? obj.type : DEFAULT_ENTITY_TYPE\n\n      const groupIndex = type.lastIndexOf('Group')\n      if (\n        groupIndex !== -1 &&\n        groupIndex === type.length - 'Group'.length &&\n        !isGroup\n      ) {\n        logger(\n          \"An entity's type that ends with `Group` must be a group entity and therefore has to have an explicit `isGroup: true` property\"\n        )\n        isValid = false\n      }\n    }\n\n    return isValid\n  }\n\n  static _cloneObject(obj) {\n    const clone = Object.assign({}, obj)\n\n    if (obj.attributes !== undefined) {\n      clone.attributes = Object.assign({}, obj.attributes)\n    }\n\n    if (obj.group !== undefined) {\n      clone.group = Object.assign({}, obj.group)\n\n      if (obj.group.attributes !== undefined) {\n        clone.group.attributes = Object.assign({}, obj.group.attributes)\n      }\n    }\n\n    return clone\n  }\n\n  static _fillInFields(obj) {\n    if (obj.type === undefined) {\n      obj.type = DEFAULT_ENTITY_TYPE\n    }\n\n    if (obj.displayName === undefined) {\n      obj.displayName = '' + obj.id\n    }\n\n    if (obj.isGroup === undefined) {\n      obj.isGroup = false\n    }\n\n    if (Number.isInteger(obj.id)) {\n      const idStr = '' + obj.id\n      if (idStr.length > 250) {\n        logger('Integer id must have 250 digits or less')\n        return false\n      }\n      obj.id = idStr\n    }\n\n    let group = null\n    if (obj.group !== undefined) {\n      group = obj.group\n    }\n\n    if (group !== null && group.displayName === undefined) {\n      group.displayName = '' + group.id\n    }\n\n    if (group !== null && group.type === undefined) {\n      group.type = obj.type + 'Group'\n    }\n\n    if (group !== null) {\n      group.isGroup = true\n    }\n\n    if (group !== null) {\n      if (Number.isInteger(group.id)) {\n        const idStr = '' + group.id\n        if (idStr.length > 250) {\n          logger('Integer id must have 250 digits or less')\n          return false\n        }\n        group.id = idStr\n      }\n    }\n\n    return true\n  }\n\n  getHash() {\n    return md5(\n      stringify({\n        ...this.object,\n        attributes: this.object.attributes || {},\n        group: {\n          ...this.object.group,\n          attributes: (this.object.group && this.object.group.attributes) || {}\n        }\n      })\n    )\n  }\n\n  getId() {\n    const obj = this.object\n    return `${obj.type}_${obj.id}`\n  }\n\n  isValid() {\n    return this.object !== null\n  }\n\n  getRawObject() {\n    return this.object\n  }\n\n  getObject() {\n    const obj = this.object\n    const clone = Object.assign({}, obj)\n    delete clone.group\n    return new AirshipObject(clone)\n  }\n\n  getGroup() {\n    const group = this.object.group || null\n    return group && new AirshipObject(group)\n  }\n}\n","import md5 from 'md5'\nimport {logger} from './logger'\n\nexport const RULE_TYPE_STRING = 'string'\nexport const RULE_TYPE_INT = 'int'\nexport const RULE_TYPE_FLOAT = 'float'\nexport const RULE_TYPE_BOOLEAN = 'boolean'\nexport const RULE_TYPE_DATE = 'date'\nexport const RULE_TYPE_DATETIME = 'datetime'\n\nexport const RULE_OPERATOR_IS = 'is'\nexport const RULE_OPERATOR_IS_NOT = 'is_not'\nexport const RULE_OPERATOR_IN = 'in'\nexport const RULE_OPERATOR_NOT_IN = 'not_in'\nexport const RULE_OPERATOR_LT = 'lt'\nexport const RULE_OPERATOR_LTE = 'lte'\nexport const RULE_OPERATOR_GT = 'gt'\nexport const RULE_OPERATOR_GTE = 'gte'\nexport const RULE_OPERATOR_FROM = 'from'\nexport const RULE_OPERATOR_UNTIL = 'until'\nexport const RULE_OPERATOR_AFTER = 'after'\nexport const RULE_OPERATOR_BEFORE = 'before'\n\nexport const getHashedValue = s => {\n  return (parseInt(md5(s), 16) * 1.0) / 340282366920938463463374607431768211455\n}\n\nexport default class Population {\n  constructor(population) {\n    this.population = population\n  }\n\n  static categorizeValueType(v) {\n    if (v === true || v === false) {\n      return 'boolean'\n    } else if (typeof v === 'number') {\n      if ((v + '').indexOf('.') >= 0) {\n        return 'float'\n      } else {\n        return 'int'\n      }\n    } else if (typeof v === 'string') {\n      const unixTimestamp = new Date(v).getTime()\n\n      if (!isNaN(unixTimestamp)) {\n        const isoFormat = new Date(v).toISOString()\n        const timeIndex = isoFormat.lastIndexOf('T00:00:00.000Z')\n        if (\n          timeIndex !== -1 &&\n          isoFormat.length - 'T00:00:00.000Z'.length === timeIndex\n        ) {\n          return 'date'\n        } else {\n          return 'datetime'\n        }\n      }\n\n      return 'string'\n    }\n    logger('Unexpected attribute value type encountered')\n    return null\n  }\n\n  _ruleMatches(rule, obj) {\n    const attributes = obj.attributes || {}\n\n    if (!attributes.hasOwnProperty(rule.attributeName)) {\n      return false\n    }\n\n    const v = attributes[rule.attributeName]\n    const attributeType = Population.categorizeValueType(v)\n\n    const numberTypes = [RULE_TYPE_INT, RULE_TYPE_FLOAT]\n\n    if (\n      numberTypes.indexOf(attributeType) !== -1 &&\n      numberTypes.indexOf(rule.attributeType) !== -1\n    ) {\n      // This is fine\n    } else if (attributeType !== rule.attributeType) {\n      return false\n    }\n\n    const targetVal = rule.value\n    const targetValList = rule.valueList\n    const op = rule.operator\n\n    if (attributeType === RULE_TYPE_STRING) {\n      if (op === RULE_OPERATOR_IS) {\n        return v === targetVal\n      } else if (op === RULE_OPERATOR_IS_NOT) {\n        return v !== targetVal\n      } else if (op === RULE_OPERATOR_IN) {\n        return targetValList.indexOf(v) !== -1\n      } else if (op === RULE_OPERATOR_NOT_IN) {\n        return targetValList.indexOf(v) === -1\n      } else {\n        logger('Invalid rule operator encountered')\n        return false\n      }\n    } else if (numberTypes.indexOf(attributeType) !== -1) {\n      if (op === RULE_OPERATOR_IS) {\n        return v === targetVal\n      } else if (op === RULE_OPERATOR_IS_NOT) {\n        return v !== targetVal\n      } else if (op === RULE_OPERATOR_IN) {\n        return targetValList.indexOf(v) !== -1\n      } else if (op === RULE_OPERATOR_NOT_IN) {\n        return targetValList.indexOf(v) === -1\n      } else if (op === RULE_OPERATOR_LT) {\n        return v < targetVal\n      } else if (op === RULE_OPERATOR_LTE) {\n        return v <= targetVal\n      } else if (op === RULE_OPERATOR_GT) {\n        return v > targetVal\n      } else if (op === RULE_OPERATOR_GTE) {\n        return v >= targetVal\n      } else {\n        logger('Invalid rule operator encountered')\n        return false\n      }\n    } else if (attributeType === RULE_TYPE_BOOLEAN) {\n      if (op === RULE_OPERATOR_IS) {\n        return v === targetVal\n      } else if (op === RULE_OPERATOR_IS_NOT) {\n        return v !== targetVal\n      } else {\n        logger('Invalid rule operator encountered')\n        return false\n      }\n    } else if (\n      attributeType === RULE_TYPE_DATE ||\n      attributeType === RULE_TYPE_DATETIME\n    ) {\n      const targetTime = targetVal && new Date(targetVal).getTime()\n      const targetTimeList =\n        targetValList && targetValList.map(tv => new Date(tv).getTime())\n      const vTime = new Date(v).getTime()\n\n      if (op === RULE_OPERATOR_IS) {\n        return vTime === targetTime\n      } else if (op === RULE_OPERATOR_IS_NOT) {\n        return vTime !== targetTime\n      } else if (op === RULE_OPERATOR_IN) {\n        return targetTimeList.indexOf(vTime) !== -1\n      } else if (op === RULE_OPERATOR_NOT_IN) {\n        return targetTimeList.indexOf(vTime) === -1\n      } else if (op === RULE_OPERATOR_FROM) {\n        return vTime >= targetTime\n      } else if (op === RULE_OPERATOR_UNTIL) {\n        return vTime <= targetTime\n      } else if (op === RULE_OPERATOR_AFTER) {\n        return vTime > targetTime\n      } else if (op === RULE_OPERATOR_BEFORE) {\n        return vTime < targetTime\n      } else {\n        logger('Invalid rule operator encountered')\n        return false\n      }\n    } else {\n      logger('Invalid attribute type encountered')\n      return false\n    }\n  }\n\n  getGateValues(obj, env, flag, sticky) {\n    const population = this.population\n    if (this.population.entityType !== obj.type) {\n      return {eligible: false}\n    }\n\n    const rules = population.rules\n\n    let matches = true\n\n    for (let i = 0; i < rules.length; i++) {\n      const r = rules[i]\n      matches = matches && this._ruleMatches(r, obj)\n    }\n\n    if (matches) {\n      const samplingHashKey = `SAMPLING:control_${flag.hashKey}:env_${\n        env.hashKey\n      }:rule_set_${this.population.hashKey}:client_object_${obj.type}_${obj.id}`\n\n      const hashedPercentage = getHashedValue(samplingHashKey)\n\n      if (\n        hashedPercentage <= this.population.percentage &&\n        this.population.percentage > 0\n      ) {\n        const splits = sticky\n          ? this.population.universes[\n              Math.max(Math.floor(hashedPercentage * 100) - 1, 0)\n            ]\n          : flag.splits\n        const splitsMap = {}\n        for (let i = 0; i < splits.length; i++) {\n          const split = splits[i]\n          splitsMap[split.treatmentId] = split\n        }\n\n        const allocationHashKey = `DISTRIBUTION:control_${flag.hashKey}:env_${\n          env.hashKey\n        }:client_object_${obj.type}_${obj.id}`\n\n        const allocationHashedPercentage = getHashedValue(allocationHashKey)\n\n        let trailingSum = 0.0\n\n        const treatments = flag.treatments.filter(t => !t.isOffTreatment)\n\n        let treatment = null\n        for (let i = 0; i < treatments.length; i++) {\n          const t = treatments[i]\n          if (splitsMap.hasOwnProperty(t.treatmentId)) {\n            trailingSum = parseFloat(\n              (trailingSum + splitsMap[t.treatmentId].percentage).toFixed(3)\n            )\n\n            if (allocationHashedPercentage <= trailingSum) {\n              treatment = t\n              break\n            }\n          }\n        }\n\n        return {treatment: treatment, eligible: true}\n      } else {\n        return {eligible: true}\n      }\n    } else {\n      return {eligible: false}\n    }\n  }\n}\n","const NS_PER_SEC = 1e9\n\nexport default class Stat {\n  static compactStats(stats) {\n    const groups = stats.reduce((groups, stat) => {\n      const key = [stat.name, stat.type].join(',')\n      groups[key] = groups[key] || []\n      groups[key].push(stat)\n      return groups\n    }, {})\n\n    return Object.values(groups).map(stats => {\n      const newStat = new Stat(stats[0].name, stats[0].type)\n      let totalDuration, totalCount\n      switch (newStat.type) {\n        case Stat.TYPE_DURATION:\n          totalDuration = stats.reduce(\n            (duration, stat) => duration + stat.averageDuration * stat.count,\n            0\n          )\n          totalCount = stats.reduce((count, stat) => count + stat.count, 0)\n          newStat.setAverageDuration(totalDuration / totalCount)\n          newStat.setCount(totalCount)\n          break\n        case Stat.TYPE_COUNT:\n          newStat.setCount(stats.reduce((count, stat) => count + stat.count, 0))\n          break\n      }\n      return newStat\n    })\n  }\n\n  constructor(name, type) {\n    const allowedTypes = [Stat.TYPE_DURATION, Stat.TYPE_COUNT]\n    if (allowedTypes.indexOf(type) === -1) {\n      throw 'Invalid stat type passed'\n    }\n    this.name = name\n    this.type = type\n\n    this.count = 0\n    this.startTime = null\n\n    this.averageDuration = 0\n  }\n\n  start() {\n    return this\n  }\n\n  stop() {\n    return this\n  }\n\n  setCount(n) {\n    this.count = n\n    return this\n  }\n\n  setAverageDuration(t) {\n    this.averageDuration = t\n    return this\n  }\n\n  getDuration() {\n    return this.averageDuration\n  }\n\n  getStatsObj() {\n    const statsObj = {\n      name: this.name\n    }\n    if (this.type === Stat.TYPE_DURATION) {\n      if (this.averageDuration !== 0) {\n        statsObj.duration = this.averageDuration\n        statsObj.unit = 'ns'\n        statsObj.count = this.count\n        return statsObj\n      }\n    } else if (this.type === Stat.TYPE_COUNT) {\n      statsObj.count = this.count\n      return statsObj\n    }\n    return null\n  }\n}\n\nStat.TYPE_DURATION = 'stat_type__duration'\nStat.TYPE_COUNT = 'stat_type__count'\n","import {logger} from './logger'\n\nexport default class Flag {\n  constructor(flag, delegate) {\n    if (typeof flag === 'string') {\n      this._isWild = true\n      this.flagName = flag\n    } else {\n      // These along with flag.flagType and flag.flagStatus\n      // should always be present\n      this.hashKey = flag.hashKey\n      this.flag = flag\n      this.codename = flag.codename\n\n      // Pass through fields\n      this.isPaused = flag.isPaused\n      this.offTreatment = flag.offTreatment\n      this.treatments = flag.treatments\n      this.treatmentsMap = flag.treatmentsMap\n      this.overrides = flag.overrides\n      this.populations = flag.populations\n      this.splits = flag.splits\n    }\n    this.delegate = delegate\n  }\n\n  isUncategorized() {\n    return Boolean(this._isWild) || this.flag.flagType === 'uncategorized'\n  }\n\n  isWild() {\n    return Boolean(this._isWild)\n  }\n\n  isArchived() {\n    return this.flag.flagStatus === 'archived'\n  }\n\n  setDelegate(delegate) {\n    this.delegate = delegate\n  }\n\n  getType() {\n    if (this._isWild) {\n      logger(\n        `Encountered uncategorized flag \"${\n          this.flagName\n        }\". Visit Airship web app to convert it to a real flag`\n      )\n      return 'uncategorized'\n    }\n\n    const flagType = this.flag.flagType\n\n    switch (flagType) {\n      case 'basic':\n        return 'basic'\n      case 'experiment':\n        return 'experiment'\n      case 'uncategorized':\n        return 'uncategorized'\n      default:\n        logger('Unexpected flag type encountered')\n        return null\n    }\n  }\n\n  getTreatment(obj) {\n    if (!this.delegate) {\n      throw 'Delegate not provided to flag'\n    }\n    return this.delegate.getTreatment(this, obj)\n  }\n\n  getPayload(obj) {\n    if (!this.delegate) {\n      throw 'Delegate not provided to flag'\n    }\n    return this.delegate.getPayload(this, obj)\n  }\n\n  isEligible(obj) {\n    if (!this.delegate) {\n      throw 'Delegate not provided to flag'\n    }\n    return this.delegate.isEligible(this, obj)\n  }\n\n  isEnabled(obj) {\n    if (!this.delegate) {\n      throw 'Delegate not provided to flag'\n    }\n    return this.delegate.isEnabled(this, obj)\n  }\n}\n","import {logger} from './logger'\nimport AirshipObject from './object'\nimport Population from './population'\nimport Stat from './stat'\nimport Flag from './flag'\n\nexport default class Environment {\n  identify(obj) {\n    this.object = obj\n  }\n\n  async maybeIngest() {}\n\n  _identifyObject(obj) {\n    const airshipObj =\n      obj instanceof AirshipObject ? obj : new AirshipObject(obj)\n\n    return airshipObj\n  }\n\n  _saveStat() {}\n\n  _saveExposure() {}\n\n  async publish(objs) {} // eslint-disable-line no-unused-vars\n\n  shutdown() {}\n\n  flag(flagName) {\n    const flag = this.router\n      ? this.router.getFlag(flagName)\n      : new Flag(flagName)\n    flag.setDelegate(this)\n    return flag\n  }\n\n  _getAllocation(flag, airshipObj) {\n    const offTreatment = flag.offTreatment\n\n    if (flag.isArchived()) {\n      logger(`The flag \"${flag.codename}\" has been archived`)\n      return {\n        treatment: offTreatment,\n        eligible: false\n      }\n    }\n\n    if (flag.isPaused) {\n      return {\n        treatment: offTreatment,\n        eligible: false\n      }\n    }\n\n    // If the airshipObj is not a valid obj,\n    // then return the offTreatment/false\n    if (!airshipObj) {\n      return {\n        treatment: offTreatment,\n        eligible: false\n      }\n    }\n\n    const id = airshipObj.getId()\n    const override = flag.overrides[id]\n\n    if (override) {\n      const treatment = flag.treatmentsMap[override.treatmentId]\n      return {\n        treatment: treatment,\n        eligible: !treatment.isOffTreatment,\n        fromOverride: true\n      }\n    }\n\n    const obj = airshipObj.getRawObject()\n    const useUniverses = flag.getType() === 'experiment'\n    const populations = flag.populations\n    let treatment = null\n    let eligible = false\n\n    for (let i = 0; i < populations.length; i++) {\n      const p = new Population(populations[i])\n      const gateValues = p.getGateValues(\n        obj,\n        this.router.getEnv(),\n        flag,\n        useUniverses\n      )\n      eligible = eligible || gateValues.eligible\n      if (gateValues.treatment) {\n        treatment = gateValues.treatment\n        break\n      }\n    }\n\n    return {\n      treatment: treatment || offTreatment,\n      eligible: eligible\n    }\n  }\n\n  _resolveAllocations(alloc1, alloc2) {\n    if (alloc1.fromOverride) {\n      return alloc1\n    }\n\n    if (alloc2.fromOverride) {\n      return alloc2\n    }\n\n    if (!alloc1.treatment.isOffTreatment) {\n      return alloc1\n    }\n\n    if (!alloc2.treatment.isOffTreatment) {\n      return alloc2\n    }\n\n    return alloc1\n  }\n\n  _getExposure(flag, airshipObj, alloc, methodCalled) {\n    const obj = airshipObj.getRawObject()\n    return {\n      flag: flag.codename,\n      type: obj.type,\n      id: obj.id,\n      treatment: alloc.treatment.codename,\n      methodCalled: methodCalled,\n      eligible: alloc.eligible,\n      timeExposed: new Date().toISOString()\n    }\n  }\n\n  getTreatment(flag, obj) {\n    const stat = new Stat('duration__get_treatment', Stat.TYPE_DURATION)\n    stat.start()\n    obj = obj || this.object\n\n    const airshipObj = this._identifyObject(obj)\n    if (!airshipObj.isValid() || flag.isUncategorized()) {\n      return 'off'\n    }\n\n    const allocation = this._getAllocation(flag, airshipObj)\n    const groupAllocation = this._getAllocation(flag, airshipObj.getGroup())\n\n    const finalAllocation = this._resolveAllocations(\n      allocation,\n      groupAllocation\n    )\n\n    const expo = this._getExposure(\n      flag,\n      airshipObj,\n      finalAllocation,\n      'get_treatment'\n    )\n    this._saveExposure(expo)\n\n    stat.stop()\n    this._saveStat(stat)\n    return finalAllocation.treatment.isGhost\n      ? (flag.offTreatment && flag.offTreatment.codename) || 'off'\n      : finalAllocation.treatment.codename\n  }\n\n  getPayload(flag, obj) {\n    const stat = new Stat('duration__get_payload', Stat.TYPE_DURATION)\n    stat.start()\n    obj = obj || this.object\n    const airshipObj = this._identifyObject(obj)\n    if (!airshipObj.isValid() || flag.isUncategorized()) {\n      return null\n    }\n\n    const allocation = this._getAllocation(flag, airshipObj)\n    const groupAllocation = this._getAllocation(flag, airshipObj.getGroup())\n\n    const finalAllocation = this._resolveAllocations(\n      allocation,\n      groupAllocation\n    )\n\n    const expo = this._getExposure(\n      flag,\n      airshipObj,\n      finalAllocation,\n      'get_payload'\n    )\n    this._saveExposure(expo)\n\n    stat.stop()\n    this._saveStat(stat)\n    return finalAllocation.treatment.isGhost\n      ? (flag.offTreatment && flag.offTreatment.payload) || null\n      : finalAllocation.treatment.payload\n  }\n\n  isEligible(flag, obj) {\n    const stat = new Stat('duration__is_eligible', Stat.TYPE_DURATION)\n    stat.start()\n    obj = obj || this.object\n\n    const airshipObj = this._identifyObject(obj)\n    if (!airshipObj.isValid() || flag.isUncategorized()) {\n      return false\n    }\n\n    const allocation = this._getAllocation(flag, airshipObj)\n    const groupAllocation = this._getAllocation(flag, airshipObj.getGroup())\n\n    const finalAllocation = this._resolveAllocations(\n      allocation,\n      groupAllocation\n    )\n\n    const expo = this._getExposure(\n      flag,\n      airshipObj,\n      finalAllocation,\n      'is_eligible'\n    )\n    this._saveExposure(expo)\n\n    stat.stop()\n    this._saveStat(stat)\n    return finalAllocation.eligible\n  }\n\n  isEnabled(flag, obj) {\n    const stat = new Stat('duration__is_enabled', Stat.TYPE_DURATION)\n    stat.start()\n    obj = obj || this.object\n\n    const airshipObj = this._identifyObject(obj)\n    if (!airshipObj.isValid() || flag.isUncategorized()) {\n      return false\n    }\n\n    const allocation = this._getAllocation(flag, airshipObj)\n    const groupAllocation = this._getAllocation(flag, airshipObj.getGroup())\n\n    const finalAllocation = this._resolveAllocations(\n      allocation,\n      groupAllocation\n    )\n\n    const expo = this._getExposure(\n      flag,\n      airshipObj,\n      finalAllocation,\n      'is_enabled'\n    )\n    this._saveExposure(expo)\n\n    stat.stop()\n    this._saveStat(stat)\n    return !finalAllocation.treatment.isOffTreatment\n  }\n}\n","// Based on https://chrisrng.svbtle.com/lru-cache-in-javascript\nclass LRUNode {\n  constructor(key, value) {\n    if (typeof key === 'undefined' || key === null) {\n      throw 'Cannot have an undefined or null key for a LRUNode'\n    }\n    if (typeof value === 'undefined' || value === null) {\n      throw 'Cannot have an undefined or null value for a LRUNode'\n    }\n    this.key = key\n    this.value = value\n    this.prev = null\n    this.next = null\n  }\n}\n\nexport default class LRU {\n  constructor(limit) {\n    this.size = 0\n    if (typeof limit === 'number') {\n      this.limit = limit\n    } else {\n      this.limit = 10\n    }\n    this.map = {}\n    this.head = null\n    this.tail = null\n  }\n\n  setHead(node) {\n    node.next = this.head\n    node.prev = null\n    if (this.head !== null) {\n      this.head.prev = node\n    }\n    this.head = node\n    if (this.tail === null) {\n      this.tail = node\n    }\n    this.size++\n    this.map[node.key] = node\n  }\n\n  set(key, value) {\n    const node = new LRUNode(key, value)\n    if (this.map[key]) {\n      this.map[key].value = node.value\n      this.remove(node.key)\n    } else {\n      if (this.size >= this.limit) {\n        delete this.map[this.tail.key]\n        this.size--\n        this.tail = this.tail.prev\n        this.tail.next = null\n      }\n    }\n    this.setHead(node)\n  }\n\n  get(key) {\n    if (this.map[key]) {\n      const value = this.map[key].value\n      const node = new LRUNode(key, value)\n      this.remove(key)\n      this.setHead(node)\n      return value\n    } else {\n      // console.log('Key ' + key + ' does not exist in the cache.')\n      return null // Return null because null cannot be a LRUNode value\n    }\n  }\n\n  remove(key) {\n    const node = this.map[key]\n    if (node.prev !== null) {\n      node.prev.next = node.next\n    } else {\n      this.head = node.next\n    }\n    if (node.next !== null) {\n      node.next.prev = node.prev\n    } else {\n      this.tail = node.prev\n    }\n    delete this.map[key]\n    this.size--\n  }\n\n  removeAll(limit) {\n    this.size = 0\n    this.map = {}\n    this.head = null\n    this.tail = null\n    if (typeof limit === 'number') {\n      this.limit = limit\n    }\n  }\n\n  forEach(callback) {\n    let node = this.head\n    let i = 0\n    while (node) {\n      callback(node, i)\n      i++\n      node = node.next\n    }\n  }\n}\n","import Flag from './flag'\n\nexport default class Router {\n  constructor(gatingInfo) {\n    this.gatingInfo = gatingInfo\n    this.gatingInfoMap = this._getGatingInfoMap(this.gatingInfo)\n  }\n\n  _getGatingInfoMap(gatingInfo) {\n    const map = {}\n\n    const flags = gatingInfo.flags\n\n    for (let i = 0; i < flags.length; i++) {\n      const flag = Object.assign({}, flags[i])\n      if (flag.flagType === 'uncategorized' || flag.flagStatus === 'archived') {\n        map[flag.codename] = new Flag(flag)\n        continue\n      }\n\n      const overrides = flag.overrides\n      const overridesMap = {}\n\n      for (let j = 0; j < overrides.length; j++) {\n        const override = overrides[j]\n\n        overridesMap[`${override.entityType}_${override.entityId}`] = override\n      }\n\n      flag.overrides = overridesMap\n\n      const treatments = flag.treatments\n      const treatmentsMap = {}\n      let offTreatment = null\n\n      for (let k = 0; k < treatments.length; k++) {\n        const treatment = treatments[k]\n\n        treatmentsMap[treatment.treatmentId] = treatment\n\n        if (treatment.isOffTreatment) {\n          offTreatment = treatment\n        }\n      }\n\n      flag.treatments = treatments\n      flag.treatmentsMap = treatmentsMap\n      flag.offTreatment = offTreatment\n\n      map[flag.codename] = new Flag(flag)\n    }\n\n    return map\n  }\n\n  getIngestionMaxItem() {\n    const sdkInfo = this.gatingInfo.sdkInfo\n    if (sdkInfo) {\n      return sdkInfo.SDK_INGESTION_MAX_ITEMS\n    }\n    return null\n  }\n\n  getBrowserIngestionMaxItems() {\n    const sdkInfo = this.gatingInfo.sdkInfo\n    if (sdkInfo) {\n      return sdkInfo.SDK_BROWSER_INGESTION_MAX_ITEMS\n    }\n    return null\n  }\n\n  getIngestionInterval() {\n    const sdkInfo = this.gatingInfo.sdkInfo\n    if (sdkInfo) {\n      return sdkInfo.SDK_INGESTION_INTERVAL * 1000\n    }\n    return null\n  }\n\n  getBrowserIngestionInterval() {\n    const sdkInfo = this.gatingInfo.sdkInfo\n    if (sdkInfo) {\n      return sdkInfo.SDK_BROWSER_INGESTION_INTERVAL * 1000\n    }\n    return null\n  }\n\n  getShouldIngestObjects() {\n    const sdkInfo = this.gatingInfo.sdkInfo\n    if (sdkInfo && typeof sdkInfo.SDK_SHOULD_INGEST_OBJECTS === 'boolean') {\n      return sdkInfo.SDK_SHOULD_INGEST_OBJECTS\n    }\n    return null\n  }\n\n  getShouldIngestStats() {\n    const sdkInfo = this.gatingInfo.sdkInfo\n    if (sdkInfo && typeof sdkInfo.SDK_SHOULD_INGEST_STATS === 'boolean') {\n      return sdkInfo.SDK_SHOULD_INGEST_STATS\n    }\n    return null\n  }\n\n  getShouldIngestExposures() {\n    const sdkInfo = this.gatingInfo.sdkInfo\n    if (sdkInfo && typeof sdkInfo.SDK_SHOULD_INGEST_EXPOSURES === 'boolean') {\n      return sdkInfo.SDK_SHOULD_INGEST_EXPOSURES\n    }\n    return null\n  }\n\n  getShouldIngestFlags() {\n    const sdkInfo = this.gatingInfo.sdkInfo\n    if (sdkInfo && typeof sdkInfo.SDK_SHOULD_INGEST_FLAGS === 'boolean') {\n      return sdkInfo.SDK_SHOULD_INGEST_FLAGS\n    }\n    return null\n  }\n\n  getFlag(flagName) {\n    return this.gatingInfoMap[flagName] || new Flag(flagName)\n  }\n\n  getEnv() {\n    return this.gatingInfo.env\n  }\n\n  isLocallyConfigured() {\n    return this.getEnv().envKey === null\n  }\n}\n","import EventSource from 'eventsource'\nimport Environment from './environment'\nimport {logger} from './logger'\nimport LRU from './lru'\nimport Router from './router'\nimport Stat from './stat'\nimport {version} from '../package.json'\n\nimport * as http from 'http'\nimport * as https from 'https'\nimport * as URL from 'url'\n\n// Default API domain\nconst DEFAULT_API_DOMAIN = 'airshiphq.com'\n\n// Primary API endpoints\nconst IDENTIFY_ENDPOINT = `/v2/identify`\nconst GATING_INFO_ENDPOINT = `/v2/gating-info`\n\n// SSE API endpoints\nconst SSE_GATING_INFO_ENDPOINT = `/v2/sse-events`\n\n// Backup API URL & endpoint\nconst BACKUP_URL = 'https://backup-api.airshiphq.com'\nconst BACKUP_GATING_INFO_ENDPOINT = `${BACKUP_URL}/v2/gating-info`\n\nconst REQUEST_TIMEOUT = 10 * 1000\n\n// Default ingestion parameters\nconst DEFAULT_INGESTION_INTERVAL = 30\nconst DEFAULT_BROWSER_INGESTION_INTERVAL = 15\nconst DEFAULT_INGESTION_MAX_ITEMS = 500\nconst DEFAULT_BROWSER_INGESTION_MAX_ITEMS = 5\n\nexport default class Airship extends Environment {\n  constructor(gatingInfoListener) {\n    super()\n\n    this.gatingInfoListener = gatingInfoListener\n    this.init()\n  }\n\n  init() {\n    this.ingestionMaxItems = DEFAULT_INGESTION_MAX_ITEMS\n    this.ingestionInterval = DEFAULT_INGESTION_INTERVAL * 1000\n\n    // eslint-disable-next-line no-undef\n    if (__BROWSER__) {\n      this.ingestionMaxItems = DEFAULT_BROWSER_INGESTION_MAX_ITEMS\n      this.ingestionInterval = DEFAULT_BROWSER_INGESTION_INTERVAL * 1000\n    }\n\n    this.objects = []\n    this.stats = []\n    this.exposures = []\n    this.flags = new Set()\n    this.oldFlags = new Set()\n\n    this.objectLRUCache = new LRU(500)\n    this.firstIngestion = true\n\n    this.shouldIngestObjects = true\n    this.shouldIngestStats = true\n    this.shouldIngestExposures = true\n    this.shouldIngestFlags = true\n\n    // this.restartIngestionWorker()\n  }\n\n  restartIngestionWorker() {\n    if (this.ingestionWorker) {\n      clearInterval(this.ingestionWorker)\n    }\n\n    this.ingestionWorker = setInterval(() => {\n      this.maybeIngest(true)\n    }, this.ingestionInterval)\n  }\n\n  async maybeIngest(force = false) {\n    if (!this.shouldIngestObjects) {\n      this.objects = []\n    }\n\n    if (!this.shouldIngestStats) {\n      this.stats = []\n    }\n\n    if (!this.shouldIngestExposures) {\n      this.exposures = []\n    }\n\n    if (!this.shouldIngestFlags) {\n      this.flags = new Set()\n    }\n\n    let shouldIngest =\n      force ||\n      (this.objects.length >= this.ingestionMaxItems ||\n        this.stats.length >= this.ingestionMaxItems ||\n        this.exposures.length >= this.ingestionMaxItems ||\n        this.flags.size > 0)\n\n    if (this.firstIngestion) {\n      shouldIngest = shouldIngest || this.objects.length > 0\n      this.firstIngestion = !shouldIngest\n    }\n\n    if (\n      this.objects.length === 0 &&\n      this.stats.length === 0 &&\n      this.exposures.length === 0 &&\n      this.flags.size === 0\n    ) {\n      shouldIngest = false\n    }\n\n    if (shouldIngest) {\n      const objects = this.objects\n      const stats = this.stats\n      const exposures = this.exposures\n      const flags = Array.from(this.flags)\n      flags.forEach(flagName => {\n        this.oldFlags.add(flagName)\n      })\n\n      this.objects = []\n      this.stats = []\n      this.exposures = []\n      this.flags = new Set()\n\n      await this.postContent(\n        this.primaryServerUrl + IDENTIFY_ENDPOINT + '/' + this.envKey,\n        JSON.stringify({\n          objects: objects,\n          stats: stats.map(s => s.getStatsObj()).filter(so => so !== null),\n          exposures: exposures,\n          flags: flags,\n          sdkInfo: {\n            name: '__SDK_NAME__',\n            version: version\n          }\n        })\n      ).catch(err => {\n        logger(err)\n      })\n    }\n  }\n\n  _identifyObject(obj) {\n    const airshipObj = Environment.prototype._identifyObject.call(this, obj)\n\n    if (!airshipObj.isValid()) {\n      return airshipObj\n    }\n    const id = airshipObj.getId()\n    const hash = airshipObj.getHash()\n    const storedHash = this.objectLRUCache.get(id)\n    if (storedHash === null || hash !== storedHash) {\n      this.objects.push(airshipObj.getRawObject())\n    }\n\n    this.objectLRUCache.set(id, hash)\n    this.maybeIngest()\n\n    return airshipObj\n  }\n\n  _compactStats() {\n    this.stats = Stat.compactStats(this.stats)\n  }\n\n  _saveStat(stat) {\n    this.stats.push(stat)\n    if (this.stats.length >= this.ingestionMaxItems) {\n      this._compactStats()\n    }\n    this.maybeIngest()\n  }\n\n  _saveExposure(expo) {\n    this.exposures.push(expo)\n    this.maybeIngest()\n  }\n\n  async publish(objs) {\n    if (!Array.isArray(objs)) {\n      logger('The \"publish\" method takes an array of objects (aka entities).')\n      return\n    }\n\n    objs.forEach(obj => {\n      this._identifyObject(obj)\n    })\n\n    await this.maybeIngest(true)\n  }\n\n  async getContent(url) {\n    const response = await fetch(url)\n    const data = await response.json()\n    return data\n  }\n\n  async postContent(url, data, contentType = 'application/json') {\n      const options = {\n        method: 'POST',\n        headers: {\n          'Content-Type': contentType,\n          'Content-Length': Buffer.byteLength(data)\n        },\n        redirect: 'follow',\n        body: JSON.stringify(data)\n      }\n      await fetch(url, options).catch(err => {\n        reject('Failed to post to url')\n      })\n  }\n\n  async _getGatingInfo() {\n    const body = await this.getContent(\n      `${this.primaryServerUrl}${GATING_INFO_ENDPOINT}/${this.envKey}?casing=camel`\n    )\n    return body\n  }\n\n  async _getBackupGatingInfo() {\n    const body = await this.getContent(\n      `${BACKUP_GATING_INFO_ENDPOINT}/${this.envKey}-camel`\n    )\n    return body\n  }\n\n  updateSDK() {\n    const ingestionMaxItems = this.router.getIngestionMaxItem()\n    const browserIngestionMaxItems = this.router.getBrowserIngestionMaxItems()\n    const ingestionInterval = this.router.getIngestionInterval()\n    const browserIngestionInterval = this.router.getBrowserIngestionInterval()\n    const shouldIngestObjects = this.router.getShouldIngestObjects()\n    const shouldIngestStats = this.router.getShouldIngestStats()\n    const shouldIngestExposures = this.router.getShouldIngestExposures()\n    const shouldIngestFlags = this.router.getShouldIngestFlags()\n\n    // eslint-disable-next-line no-undef\n    if (__BROWSER__) {\n      // Use SDK info's browserIngestionMaxItems threshold instead (if it exists)\n      if (\n        typeof browserIngestionMaxItems === 'number' &&\n        browserIngestionMaxItems > 0\n      ) {\n        this.ingestionMaxItems = browserIngestionMaxItems\n        this.restartIngestionWorker()\n      }\n\n      // Use SDK info's ingestionInterval instead (if it exists)\n      if (\n        typeof browserIngestionInterval === 'number' &&\n        browserIngestionInterval > 0 &&\n        browserIngestionInterval != this.ingestionInterval\n      ) {\n        this.ingestionInterval = browserIngestionInterval\n        this.restartIngestionWorker()\n      }\n    } else {\n      // Use SDK info's ingestionMaxItem threshold instead (if it exists)\n      if (typeof ingestionMaxItems === 'number' && ingestionMaxItems > 0) {\n        this.ingestionMaxItems = ingestionMaxItems\n        this.restartIngestionWorker()\n      }\n\n      // Use SDK info's ingestionInterval instead (if it exists)\n      if (\n        typeof ingestionInterval === 'number' &&\n        ingestionInterval > 0 &&\n        ingestionInterval != this.ingestionInterval\n      ) {\n        this.ingestionInterval = ingestionInterval\n        this.restartIngestionWorker()\n      }\n    }\n\n    // Check if SDK info directs SDK to ingest entities\n    if (typeof shouldIngestObjects === 'boolean') {\n      this.shouldIngestObjects = shouldIngestObjects\n    }\n\n    // Check if SDK info directs SDK to ingest stats\n    if (typeof shouldIngestStats === 'boolean') {\n      this.shouldIngestStats = shouldIngestStats\n    }\n\n    // Check if SDK info directs SDK to ingest exposures\n    if (typeof shouldIngestExposures === 'boolean') {\n      this.shouldIngestExposures = shouldIngestExposures\n    }\n\n    // Check if SDK info directs SDK to ingest flags\n    if (typeof shouldIngestFlags === 'boolean') {\n      this.shouldIngestFlags = shouldIngestFlags\n    }\n  }\n\n  async updateGatingInfo(statName, fetchFn) {\n    try {\n      const stat = new Stat(statName, Stat.TYPE_DURATION)\n      stat.start()\n      const result = await fetchFn()\n      const gatingInfo = result\n      this.router = new Router(gatingInfo)\n      this.updateSDK()\n      if (this.gatingInfoListener) {\n        this.gatingInfoListener(gatingInfo)\n      }\n      stat.stop()\n      this._saveStat(stat)\n    } catch (err) {\n      console.log(err)\n      logger(err)\n\n      return false\n    }\n    return true\n  }\n\n  async configure(\n    envKey,\n    subscribeToUpdates = true,\n    apiDomain = DEFAULT_API_DOMAIN\n  ) {\n    const envKeyRegex = /^[a-z0-9]{16}$/\n    if (!envKey.match(envKeyRegex)) {\n      throw 'options[\"envKey\"] should be a string of lowercase characters and digits. Double check on the Airship web app.'\n    }\n\n    this.envKey = envKey\n    this.subscribeToUpdates = subscribeToUpdates\n\n    this.primaryServerUrl = `https://api.${apiDomain}`\n    this.sseServerUrl = `https://sse.${apiDomain}`\n\n    this.init()\n\n    this.failed = false\n\n\n    // First try the Airship server\n    if (\n      !(await this.updateGatingInfo(\n        'duration__gating_info',\n        this._getGatingInfo.bind(this)\n      ))\n    ) {\n      // Then try the Airship CloudFront distribution\n      this.failed = !(await this.updateGatingInfo(\n        'duration__cloudfront_gating_info',\n        this._getBackupGatingInfo.bind(this)\n      ))\n    }\n\n    if (this.failed) {\n      throw 'Failed to retrieve initial gating information'\n    }\n\n    if (subscribeToUpdates) {\n      this._subscribeToUpdates()\n      this._policeSSE()\n    }\n  }\n\n  async shutdown() {\n    if (this.ingestionWorker) {\n      clearInterval(this.ingestionWorker)\n    }\n\n    this._unpoliceSSE()\n    this._unsubscribeFromUpdates()\n\n    await this.maybeIngest(true)\n  }\n\n  flag(flagName) {\n    const flag = Environment.prototype.flag.call(this, flagName)\n    if (flag.isWild()) {\n      // Register the new uncategorized flag\n      if (!this.oldFlags.has(flagName)) {\n        this.flags.add(flagName)\n        this.maybeIngest()\n      }\n    }\n    return flag\n  }\n\n  _policeSSE() {\n    this._unpoliceSSE()\n    this.policeSSEInterval = setInterval(() => {\n      const now = Date.now()\n      const then = this.lastSSEConnectTimestamp || 0\n      if ((now - then) / 1000 > 30) {\n        logger(\n          'Did not receive a keepalive for more than 30 seconds. Reconnecting.'\n        )\n        this._subscribeToUpdates()\n      }\n    }, 5 * 1000)\n\n    this.pollGatingInfoInterval = setInterval(() => {\n      const now = Date.now()\n      const then = this.lastSSEConnectTimestamp || 0\n      if ((now - then) / 1000 > 60) {\n        logger(\n          'Did not receive a keepalive for more than 30 seconds. Polling gating info.'\n        )\n        this.updateGatingInfo(\n          'duration__cloudfront_gating_info',\n          this._getBackupGatingInfo.bind(this)\n        ).then(\n          () => logger('Polled gating info from CloudFront'),\n          () => logger('Failed polling gating info from CloudFront')\n        )\n      }\n    }, 60 * 1000)\n  }\n\n  _unpoliceSSE() {\n    if (this.policeSSEInterval) {\n      clearInterval(this.policeSSEInterval)\n      delete this.policeSSEInterval\n\n      if (this.lastSSEConnectTimestamp) {\n        delete this.lastSSEConnectTimestamp\n      }\n    }\n\n    if (this.pollGatingInfoInterval) {\n      clearInterval(this.pollGatingInfoInterval)\n      delete this.pollGatingInfoInterval\n    }\n  }\n\n  _subscribeToUpdates() {\n    this._unsubscribeFromUpdates()\n\n    this.eventSource = new EventSource(\n      `${this.sseServerUrl}${SSE_GATING_INFO_ENDPOINT}?envkey=${this.envKey}&casing=camel`\n    )\n    this.eventSource.addEventListener('gatingInfoUpdate', evt => {\n      const gatingInfo = JSON.parse(evt.data)\n      this.router = new Router(gatingInfo)\n      this.updateSDK()\n      if (this.gatingInfoListener) {\n        this.gatingInfoListener(gatingInfo)\n      }\n      this.lastSSEConnectTimestamp = Date.now()\n    })\n\n    this.eventSource.addEventListener('keepalive', () => {\n      this.lastSSEConnectTimestamp = Date.now()\n    })\n  }\n\n  _unsubscribeFromUpdates() {\n    if (this.eventSource) {\n      this.eventSource.close()\n      delete this.eventSource\n    }\n  }\n}\n","import {logger} from '../logger'\nimport {isValidFlagConfig} from '../validators/core_validator'\nimport Population, {\n  RULE_TYPE_STRING,\n  RULE_TYPE_INT,\n  RULE_TYPE_FLOAT,\n  RULE_TYPE_BOOLEAN,\n  RULE_TYPE_DATE,\n  RULE_TYPE_DATETIME,\n  RULE_OPERATOR_IS,\n  RULE_OPERATOR_IS_NOT,\n  RULE_OPERATOR_IN,\n  RULE_OPERATOR_NOT_IN,\n  RULE_OPERATOR_LT,\n  RULE_OPERATOR_LTE,\n  RULE_OPERATOR_GT,\n  RULE_OPERATOR_GTE,\n  RULE_OPERATOR_FROM,\n  RULE_OPERATOR_UNTIL,\n  RULE_OPERATOR_AFTER,\n  RULE_OPERATOR_BEFORE\n} from '../population'\n\nconst RULE_TYPE_TO_ALLOWED_OPERATORS = {\n  [RULE_TYPE_STRING]: new Set([\n    RULE_OPERATOR_IS,\n    RULE_OPERATOR_IS_NOT,\n    RULE_OPERATOR_IN,\n    RULE_OPERATOR_NOT_IN\n  ]),\n  [RULE_TYPE_INT]: new Set([\n    RULE_OPERATOR_IS,\n    RULE_OPERATOR_IS_NOT,\n    RULE_OPERATOR_IN,\n    RULE_OPERATOR_NOT_IN,\n    RULE_OPERATOR_LT,\n    RULE_OPERATOR_LTE,\n    RULE_OPERATOR_GT,\n    RULE_OPERATOR_GTE\n  ]),\n  [RULE_TYPE_FLOAT]: new Set([\n    RULE_OPERATOR_IS,\n    RULE_OPERATOR_IS_NOT,\n    RULE_OPERATOR_IN,\n    RULE_OPERATOR_NOT_IN,\n    RULE_OPERATOR_LT,\n    RULE_OPERATOR_LTE,\n    RULE_OPERATOR_GT,\n    RULE_OPERATOR_GTE\n  ]),\n  [RULE_TYPE_BOOLEAN]: new Set([RULE_OPERATOR_IS, RULE_OPERATOR_IS_NOT]),\n  [RULE_TYPE_DATE]: new Set([\n    RULE_OPERATOR_IS,\n    RULE_OPERATOR_IS_NOT,\n    RULE_OPERATOR_IN,\n    RULE_OPERATOR_NOT_IN,\n    RULE_OPERATOR_FROM,\n    RULE_OPERATOR_UNTIL,\n    RULE_OPERATOR_AFTER,\n    RULE_OPERATOR_BEFORE\n  ]),\n  [RULE_TYPE_DATETIME]: new Set([\n    RULE_OPERATOR_IS,\n    RULE_OPERATOR_IS_NOT,\n    RULE_OPERATOR_IN,\n    RULE_OPERATOR_NOT_IN,\n    RULE_OPERATOR_FROM,\n    RULE_OPERATOR_UNTIL,\n    RULE_OPERATOR_AFTER,\n    RULE_OPERATOR_BEFORE\n  ])\n}\n\nexport const transformFlagConfig = flagConfig => {\n  if (!isValidFlagConfig(flagConfig)) {\n    return null\n  }\n\n  const flags = []\n  const keys = Object.keys(flagConfig)\n  for (let i = 0; i < keys.length; i++) {\n    const key = keys[i]\n    const config = flagConfig[key]\n    const active = config.active !== undefined ? config.active : true\n    const flagInfo = {\n      flagType: 'basic',\n      hashKey: key,\n      isPaused: !active,\n      isWebAccessible: __BROWSER__, // eslint-disable-line no-undef\n      codename: key,\n      flagStatus: 'operational'\n    }\n    const whitelist = config.whitelist || []\n    const blacklist = config.blacklist || []\n    const blacklistSet = new Set(blacklist)\n    const filteredWhitelist = whitelist.filter(i => !blacklistSet.has(i))\n\n    flagInfo.treatments = [\n      {\n        treatmentId: 'off-treatment',\n        codename: 'off',\n        isControl: false,\n        isOffTreatment: true\n      },\n      {\n        treatmentId: 'on-treatment',\n        codename: 'on',\n        isControl: false,\n        isOffTreatment: false\n      }\n    ]\n\n    flagInfo.overrides = []\n\n    flagInfo.overrides = flagInfo.overrides.concat(\n      filteredWhitelist.map(i => ({\n        treatmentId: 'on-treatment',\n        entityType: 'User',\n        entityId: i.toString()\n      }))\n    )\n\n    flagInfo.overrides = flagInfo.overrides.concat(\n      blacklist.map(i => ({\n        treatmentId: 'off-treatment',\n        entityType: 'User',\n        entityId: i.toString()\n      }))\n    )\n\n    flagInfo.splits = [{treatmentId: 'on-treatment', percentage: 1}]\n\n    if (config.population) {\n      const rules = config.population || []\n      const ruleInfos = []\n\n      for (let j = 0; j < rules.length; j++) {\n        const r = rules[j]\n        let type\n        if (Array.isArray(r.value)) {\n          const types = new Set(\n            r.value.map(v => Population.categorizeValueType(v))\n          )\n\n          if (types.size != 1) {\n            logger(\n              \"Population's filter criteria each should have a singular value type. In other words, do not mix strings with numbers in the same array, for example.\"\n            )\n            return null\n          }\n\n          type = Array.from(types)[0]\n        } else {\n          type = Population.categorizeValueType(r.value)\n        }\n\n        const rInfo = {\n          attributeName: r.attribute,\n          attributeType: type,\n          operator: r.operator,\n          value: !Array.isArray(r.value) ? r.value : null,\n          valueList: !Array.isArray(r.value) ? null : r.value\n        }\n\n        if (!RULE_TYPE_TO_ALLOWED_OPERATORS[type].has(r.operator)) {\n          logger(\n            `Population's filter operator \\`${\n              r.operator\n            }\\` is not allowed for filter type \\`${type}\\``\n          )\n          return null\n        }\n\n        if (rInfo.valueList) {\n          if (\n            rInfo.operator !== RULE_OPERATOR_IN &&\n            rInfo.operator !== RULE_OPERATOR_NOT_IN\n          ) {\n            logger(\n              \"Population's filter operator must be `in` or `not_in` if the value is an array.\"\n            )\n            return null\n          }\n        } else {\n          if (\n            rInfo.operator === RULE_OPERATOR_IN &&\n            rInfo.operator === RULE_OPERATOR_NOT_IN\n          ) {\n            logger(\n              \"Population's filter operator must not be `in` or `not_in` if the value is a number, boolean or string.\"\n            )\n            return null\n          }\n        }\n\n        ruleInfos.push(rInfo)\n      }\n\n      flagInfo.populations = [\n        {\n          hashKey: 'population-1',\n          entityType: 'User',\n          percentage: config.sample || 0.0,\n          rules: ruleInfos,\n          universes: []\n        }\n      ]\n    } else {\n      flagInfo.populations = [\n        {\n          hashKey: 'population-1',\n          entityType: 'User',\n          percentage: config.sample || 0.0,\n          rules: [],\n          universes: []\n        }\n      ]\n    }\n\n    flags.push(flagInfo)\n  }\n\n  return {\n    flags: flags,\n    env: {\n      hashKey: 'env-1',\n      envKey: null\n    }\n  }\n}\n","import Environment from './environment'\nimport Router from './router'\nimport {transformFlagConfig} from './transformers/core_transformer'\n\nexport default class Core extends Environment {\n  async configure(flagConfig) {\n    const gatingInfo = transformFlagConfig(flagConfig)\n    if (gatingInfo === null) {\n      throw 'Failed to transform flagConfig into initial gating information'\n    }\n    this.router = new Router(gatingInfo)\n  }\n}\n","import {setLogger} from './logger'\nimport Airship from './airship'\nimport Core from './core'\n\nconst defaultEnv = new Core()\ndefaultEnv.configure({})\n\nexport class FlaggerBase {\n  constructor() {\n    this.gatingInfoListeners = []\n  }\n\n  static _isDict(obj) {\n    return obj !== undefined && obj !== null && obj.constructor === Object\n  }\n\n  async publish(objs) {\n    if (this.environment) {\n      await this.environment.publish(objs)\n    } else {\n      throw 'Airship must be configured first before `publish` can be called'\n    }\n  }\n\n  // This will allow for async/await\n  async configure(options) {\n    if (!FlaggerBase._isDict(options)) {\n      throw '<options> must be dictionary'\n    }\n\n    const envKey = options.envKey\n    const flagConfig = options.flagConfig\n\n    if (!envKey && !flagConfig) {\n      throw '<options> must contain envKey corresponding to an environment key or a flagConfig dictionary to configure locally'\n    }\n\n    const subscribeToUpdates =\n      options.subscribeToUpdates === false ? false : true\n\n    if (envKey) {\n      if (\n        this.environment &&\n        this.environment.envKey === envKey &&\n        this.environment.subscribeToUpdates === subscribeToUpdates &&\n        this.environment.environmentPromise &&\n        !this.environment.failed\n      ) {\n        await this.environment.environmentPromise\n      } else {\n        if (this.environment) {\n          await this.environment.shutdown()\n        }\n        this.environment = new Airship(this.handleGatingInfoUpdate.bind(this))\n        const promise = this.environment.configure(\n          envKey,\n          options.subscribeToUpdates,\n          options.apiDomain\n        )\n        this.environment.environmentPromise = promise\n        await promise\n      }\n    } else {\n      if (this.environment) {\n        await this.environment.shutdown()\n      }\n      this.environment = new Core()\n      await this.environment.configure(flagConfig)\n    }\n  }\n\n  async shutdown() {\n    if (this.environment) {\n      await this.environment.shutdown()\n      delete this.environment\n    } else {\n      throw 'Airship must be configured first before `shutdown` can be called'\n    }\n  }\n\n  flag(flagName) {\n    return (this.environment || defaultEnv).flag(flagName)\n  }\n\n  setErrorListener(fn) {\n    setLogger(fn)\n  }\n\n  handleGatingInfoUpdate(gatingInfo) {\n    this.gatingInfoListeners.forEach(listener => listener(gatingInfo))\n  }\n\n  addGatingInfoListener(listener) {\n    this.gatingInfoListeners.push(listener)\n  }\n\n  removeGatingInfoListener(listener) {\n    this.gatingInfoListeners = this.gatingInfoListeners.filter(\n      l => l !== listener\n    )\n  }\n\n  identify(obj) {\n    if (this.environment) {\n      this.environment.identify(obj)\n      this.environment._identifyObject(obj)\n      this.environment.maybeIngest(true)\n    } else {\n      throw 'Airship must be configured first before `identify` can be called'\n    }\n  }\n}\n\nconst Flagger = new FlaggerBase()\n\nexport default Flagger\n","import Airship, {FlaggerBase} from './index'\nObject.assign(Airship, {FlaggerBase})\n\nexport default Airship\n"],"names":["logger","x","console","error","validate","DEFAULT_ENTITY_TYPE","AirshipObject","obj","isValid","isValidObject","_cloneObject","_fillInFields","object","md5","stringify","this","attributes","group","type","id","clone","_Object$assign","errors","map","e","message","isGroup","undefined","groupIndex","lastIndexOf","length","displayName","_Number$isInteger","idStr","RULE_TYPE_STRING","RULE_TYPE_FLOAT","RULE_TYPE_BOOLEAN","RULE_TYPE_DATE","RULE_TYPE_DATETIME","RULE_OPERATOR_IS","RULE_OPERATOR_IS_NOT","RULE_OPERATOR_IN","RULE_OPERATOR_NOT_IN","RULE_OPERATOR_LT","RULE_OPERATOR_LTE","RULE_OPERATOR_GT","RULE_OPERATOR_GTE","RULE_OPERATOR_FROM","RULE_OPERATOR_UNTIL","RULE_OPERATOR_AFTER","RULE_OPERATOR_BEFORE","getHashedValue","s","_parseInt","Population","population","rule","hasOwnProperty","attributeName","v","attributeType","categorizeValueType","numberTypes","indexOf","targetVal","value","targetValList","valueList","op","operator","targetTime","Date","getTime","targetTimeList","tv","vTime","env","flag","sticky","entityType","eligible","rules","matches","i","r","_ruleMatches","samplingHashKey","hashKey","hashedPercentage","percentage","splits","universes","Math","max","floor","splitsMap","split","treatmentId","allocationHashKey","allocationHashedPercentage","trailingSum","treatments","filter","t","isOffTreatment","treatment","_parseFloat","toFixed","unixTimestamp","isNaN","isoFormat","toISOString","timeIndex","Stat","name","TYPE_DURATION","TYPE_COUNT","count","startTime","averageDuration","stats","groups","reduce","stat","key","join","push","_Object$values","totalDuration","totalCount","newStat","duration","setAverageDuration","setCount","n","statsObj","unit","Flag","delegate","_isWild","flagName","codename","isPaused","offTreatment","treatmentsMap","overrides","populations","Boolean","flagType","flagStatus","getTreatment","getPayload","isEligible","isEnabled","Environment","objs","router","getFlag","setDelegate","airshipObj","isArchived","getId","override","fromOverride","getRawObject","useUniverses","getType","gateValues","getGateValues","getEnv","alloc1","alloc2","alloc","methodCalled","timeExposed","start","_identifyObject","isUncategorized","allocation","_getAllocation","groupAllocation","getGroup","finalAllocation","_resolveAllocations","expo","_getExposure","_saveExposure","stop","_saveStat","isGhost","payload","LRUNode","prev","next","LRU","limit","size","head","tail","node","remove","setHead","callback","Router","gatingInfo","gatingInfoMap","_getGatingInfoMap","flags","overridesMap","j","entityId","k","sdkInfo","SDK_INGESTION_MAX_ITEMS","SDK_BROWSER_INGESTION_MAX_ITEMS","SDK_INGESTION_INTERVAL","SDK_BROWSER_INGESTION_INTERVAL","SDK_SHOULD_INGEST_OBJECTS","SDK_SHOULD_INGEST_STATS","SDK_SHOULD_INGEST_EXPOSURES","SDK_SHOULD_INGEST_FLAGS","envKey","BACKUP_GATING_INFO_ENDPOINT","Airship","gatingInfoListener","init","ingestionMaxItems","ingestionInterval","DEFAULT_INGESTION_INTERVAL","DEFAULT_BROWSER_INGESTION_INTERVAL","objects","exposures","oldFlags","objectLRUCache","firstIngestion","shouldIngestObjects","shouldIngestStats","shouldIngestExposures","shouldIngestFlags","ingestionWorker","clearInterval","setInterval","_this2","maybeIngest","force","shouldIngest","_Array$from","forEach","_this3","add","postContent","primaryServerUrl","_JSON$stringify","getStatsObj","so","version","catch","err","prototype","call","hash","getHash","storedHash","get","set","compactStats","_compactStats","_Array$isArray","_this4","url","fetch","response","json","data","contentType","options","method","headers","Buffer","byteLength","redirect","body","reject","getContent","getIngestionMaxItem","browserIngestionMaxItems","getBrowserIngestionMaxItems","browserIngestionInterval","getIngestionInterval","getBrowserIngestionInterval","getShouldIngestObjects","getShouldIngestStats","getShouldIngestExposures","getShouldIngestFlags","restartIngestionWorker","statName","fetchFn","result","updateSDK","log","subscribeToUpdates","apiDomain","envKeyRegex","match","sseServerUrl","failed","updateGatingInfo","_getGatingInfo","bind","_getBackupGatingInfo","_subscribeToUpdates","_policeSSE","_unpoliceSSE","_unsubscribeFromUpdates","isWild","has","policeSSEInterval","_Date$now","_this5","lastSSEConnectTimestamp","pollGatingInfoInterval","then","eventSource","EventSource","addEventListener","evt","JSON","parse","_this6","close","RULE_TYPE_TO_ALLOWED_OPERATORS","transformFlagConfig","flagConfig","keys","_Object$keys","config","flagInfo","active","isWebAccessible","whitelist","blacklist","blacklistSet","filteredWhitelist","isControl","concat","toString","ruleInfos","types","rInfo","attribute","sample","Core","defaultEnv","configure","FlaggerBase","gatingInfoListeners","environment","publish","_isDict","environmentPromise","shutdown","handleGatingInfoUpdate","promise","fn","listener","l","identify","constructor","Object","Flagger"],"mappings":"+1IAAO,IAAIA,EAAS,SAAAC,GAElBC,QAAQC,MAAMF,ICGhB,IAAMG,EAAW,kBACR,GAGIC,EAAsB,OAEdC,wBACPC,iBACNC,EAAUF,EAAcG,cAAcF,GAErCC,GAKLD,EAAMD,EAAcI,aAAaH,GACjCC,EAAUF,EAAcK,cAAcJ,QAOjCK,OALAJ,EAKSD,EAJE,WARTK,OAAS,wDAiHTC,EACLC,OACKC,KAAKH,QACRI,WAAYD,KAAKH,OAAOI,YAAc,GACtCC,WACKF,KAAKH,OAAOK,OACfD,WAAaD,KAAKH,OAAOK,OAASF,KAAKH,OAAOK,MAAMD,YAAe,6CAOnET,EAAMQ,KAAKH,uBACPL,EAAIW,iBAAQX,EAAIY,6CAIH,OAAhBJ,KAAKH,qDAILG,KAAKH,+CAINL,EAAMQ,KAAKH,OACXQ,EAAQC,EAAc,GAAId,iBACzBa,EAAMH,MACN,IAAIX,EAAcc,0CAInBH,EAAQF,KAAKH,OAAOK,OAAS,YAC5BA,GAAS,IAAIX,EAAcW,2CApIfV,OACfC,GA1BC,KA2BAA,GACHR,EAAOI,EAASkB,OAAOC,IAAI,SAAAC,UAAKA,EAAEC,WAGhCjB,EAAS,KACLkB,OAA0BC,IAAhBpB,EAAImB,SAAwBnB,EAAImB,QAC1CR,OAAoBS,IAAbpB,EAAIW,KAAqBX,EAAIW,KAAOb,EAE3CuB,EAAaV,EAAKW,YAAY,UAElB,IAAhBD,GACAA,IAAeV,EAAKY,OAAS,QAAQA,QACpCJ,IAED1B,EACE,iIAEFQ,GAAU,UAIPA,uCAGWD,OACZa,EAAQC,EAAc,GAAId,eAEToB,IAAnBpB,EAAIS,aACNI,EAAMJ,WAAaK,EAAc,GAAId,EAAIS,kBAGzBW,IAAdpB,EAAIU,QACNG,EAAMH,MAAQI,EAAc,GAAId,EAAIU,YAEPU,IAAzBpB,EAAIU,MAAMD,aACZI,EAAMH,MAAMD,WAAaK,EAAc,GAAId,EAAIU,MAAMD,cAIlDI,wCAGYb,WACFoB,IAAbpB,EAAIW,OACNX,EAAIW,KAAOb,QAGWsB,IAApBpB,EAAIwB,cACNxB,EAAIwB,YAAc,GAAKxB,EAAIY,SAGTQ,IAAhBpB,EAAImB,UACNnB,EAAImB,SAAU,GAGZM,EAAiBzB,EAAIY,IAAK,KACtBc,EAAQ,GAAK1B,EAAIY,MACJ,IAAfc,EAAMH,cACR9B,EAAO,4CACA,EAETO,EAAIY,GAAKc,MAGPhB,EAAQ,aACMU,IAAdpB,EAAIU,QACNA,EAAQV,EAAIU,OAGA,OAAVA,QAAwCU,IAAtBV,EAAMc,cAC1Bd,EAAMc,YAAc,GAAKd,EAAME,IAGnB,OAAVF,QAAiCU,IAAfV,EAAMC,OAC1BD,EAAMC,KAAOX,EAAIW,KAAO,SAGZ,OAAVD,IACFA,EAAMS,SAAU,GAGJ,OAAVT,GACEe,EAAiBf,EAAME,IAAK,KACxBc,EAAQ,GAAKhB,EAAME,MACN,IAAfc,EAAMH,cACR9B,EAAO,4CACA,EAETiB,EAAME,GAAKc,SAIR,WC1HEC,EAAmB,SAEnBC,EAAkB,QAClBC,EAAoB,UACpBC,EAAiB,OACjBC,EAAqB,WAErBC,EAAmB,KACnBC,EAAuB,SACvBC,EAAmB,KACnBC,EAAuB,SACvBC,EAAmB,KACnBC,EAAoB,MACpBC,EAAmB,KACnBC,EAAoB,MACpBC,EAAqB,OACrBC,EAAsB,QACtBC,EAAsB,QACtBC,EAAuB,SAEvBC,EAAiB,SAAAC,UACG,EAAvBC,EAASxC,EAAIuC,GAAI,IAAa,qBAGnBE,wBACPC,kBACLA,WAAaA,iDAkCPC,EAAMjD,OACXS,EAAaT,EAAIS,YAAc,OAEhCA,EAAWyC,eAAeD,EAAKE,sBAC3B,MAGHC,EAAI3C,EAAWwC,EAAKE,eACpBE,EAAgBN,EAAWO,oBAAoBF,GAE/CG,EAAc,CArEK,MAqEW3B,OAGM,IAAxC2B,EAAYC,QAAQH,KACyB,IAA7CE,EAAYC,QAAQP,EAAKI,qBAGpB,GAAIA,IAAkBJ,EAAKI,qBACzB,MAGHI,EAAYR,EAAKS,MACjBC,EAAgBV,EAAKW,UACrBC,EAAKZ,EAAKa,YAEZT,IAAkB1B,SAChBkC,IAAO7B,EACFoB,IAAMK,EACJI,IAAO5B,EACTmB,IAAMK,EACJI,IAAO3B,GACqB,IAA9ByB,EAAcH,QAAQJ,GACpBS,IAAO1B,GACqB,IAA9BwB,EAAcH,QAAQJ,IAE7B3D,EAAO,sCACA,GAEJ,IAA4C,IAAxC8D,EAAYC,QAAQH,UACzBQ,IAAO7B,EACFoB,IAAMK,EACJI,IAAO5B,EACTmB,IAAMK,EACJI,IAAO3B,GACqB,IAA9ByB,EAAcH,QAAQJ,GACpBS,IAAO1B,GACqB,IAA9BwB,EAAcH,QAAQJ,GACpBS,IAAOzB,EACTgB,EAAIK,EACFI,IAAOxB,EACTe,GAAKK,EACHI,IAAOvB,EACLmB,EAAJL,EACES,IAAOtB,EACJkB,GAALL,GAEP3D,EAAO,sCACA,GAEJ,GAAI4D,IAAkBxB,SACvBgC,IAAO7B,EACFoB,IAAMK,EACJI,IAAO5B,EACTmB,IAAMK,GAEbhE,EAAO,sCACA,GAEJ,GACL4D,IAAkBvB,GAClBuB,IAAkBtB,SA4BlBtC,EAAO,uCACA,MA3BDsE,EAAaN,GAAa,IAAIO,KAAKP,GAAWQ,UAC9CC,EACJP,GAAiBA,EAAc3C,IAAI,SAAAmD,UAAM,IAAIH,KAAKG,GAAIF,YAClDG,EAAQ,IAAIJ,KAAKZ,GAAGa,iBAEtBJ,IAAO7B,EACFoC,IAAUL,EACRF,IAAO5B,EACTmC,IAAUL,EACRF,IAAO3B,GAC0B,IAAnCgC,EAAeV,QAAQY,GACrBP,IAAO1B,GAC0B,IAAnC+B,EAAeV,QAAQY,GACrBP,IAAOrB,EACAuB,GAATK,EACEP,IAAOpB,EACT2B,GAASL,EACPF,IAAOnB,EACDqB,EAARK,EACEP,IAAOlB,EACTyB,EAAQL,GAEftE,EAAO,sCACA,yCAQCO,EAAKqE,EAAKC,EAAMC,OACtBvB,EAAaxC,KAAKwC,cACpBxC,KAAKwC,WAAWwB,aAAexE,EAAIW,WAC9B,CAAC8D,UAAU,WAGdC,EAAQ1B,EAAW0B,MAErBC,GAAU,EAELC,EAAI,EAAGA,EAAIF,EAAMnD,OAAQqD,IAAK,KAC/BC,EAAIH,EAAME,GAChBD,EAAUA,GAAWnE,KAAKsE,aAAaD,EAAG7E,MAGxC2E,EAAS,KACLI,6BAAsCT,EAAKU,wBAC/CX,EAAIW,6BACOxE,KAAKwC,WAAWgC,kCAAyBhF,EAAIW,iBAAQX,EAAIY,IAEhEqE,EAAmBrC,EAAemC,MAGtCE,GAAoBzE,KAAKwC,WAAWkC,YACP,EAA7B1E,KAAKwC,WAAWkC,WAChB,SACMC,EAASZ,EACX/D,KAAKwC,WAAWoC,UACdC,KAAKC,IAAID,KAAKE,MAAyB,IAAnBN,GAA0B,EAAG,IAEnDX,EAAKa,OACHK,EAAY,GACTZ,EAAI,EAAGA,EAAIO,EAAO5D,OAAQqD,IAAK,KAChCa,EAAQN,EAAOP,GACrBY,EAAUC,EAAMC,aAAeD,UAG3BE,iCAA4CrB,EAAKU,wBACrDX,EAAIW,kCACYhF,EAAIW,iBAAQX,EAAIY,IAE5BgF,EAA6BhD,EAAe+C,GAE9CE,EAAc,EAEZC,EAAaxB,EAAKwB,WAAWC,OAAO,SAAAC,UAAMA,EAAEC,iBAE9CC,EAAY,KACPtB,EAAI,EAAGA,EAAIkB,EAAWvE,OAAQqD,IAAK,KACpCoB,EAAIF,EAAWlB,MACjBY,EAAUtC,eAAe8C,EAAEN,cAKzBE,IAJJC,EAAcM,GACXN,EAAcL,EAAUQ,EAAEN,aAAaR,YAAYkB,QAAQ,KAGf,CAC7CF,EAAYF,eAMX,CAACE,UAAWA,EAAWzB,UAAU,SAEjC,CAACA,UAAU,SAGb,CAACA,UAAU,iDAzMKrB,OACf,IAANA,IAAoB,IAANA,QACT,UACF,GAAiB,iBAANA,SACa,IAAxBA,EAAI,IAAII,QAAQ,KACZ,QAEA,MAEJ,GAAiB,iBAANJ,SAkBlB3D,EAAO,+CACA,SAlBC4G,EAAgB,IAAIrC,KAAKZ,GAAGa,aAE7BqC,MAAMD,SAaJ,aAZCE,EAAY,IAAIvC,KAAKZ,GAAGoD,cACxBC,EAAYF,EAAUjF,YAAY,yBAEvB,IAAfmF,GACAF,EAAUhF,OAAS,iBAAiBA,SAAWkF,EAExC,OAEA,oBCnDIC,yBA8BPC,EAAMhG,iBAEoB,IADf,CAAC+F,EAAKE,cAAeF,EAAKG,YAC9BrD,QAAQ7C,QACjB,gCAEHgG,KAAOA,OACPhG,KAAOA,OAEPmG,MAAQ,OACRC,UAAY,UAEZC,gBAAkB,sDAxCLC,OACZC,EAASD,EAAME,OAAO,SAACD,EAAQE,OAC7BC,EAAM,CAACD,EAAKT,KAAMS,EAAKzG,MAAM2G,KAAK,YACxCJ,EAAOG,GAAOH,EAAOG,IAAQ,GAC7BH,EAAOG,GAAKE,KAAKH,GACVF,GACN,WAEIM,EAAcN,GAAQlG,IAAI,SAAAiG,OAE3BQ,EAAeC,EADbC,EAAU,IAAIjB,EAAKO,EAAM,GAAGN,KAAMM,EAAM,GAAGtG,aAEzCgH,EAAQhH,WACT+F,EAAKE,cACRa,EAAgBR,EAAME,OACpB,SAACS,EAAUR,UAASQ,EAAWR,EAAKJ,gBAAkBI,EAAKN,OAC3D,GAEFY,EAAaT,EAAME,OAAO,SAACL,EAAOM,UAASN,EAAQM,EAAKN,OAAO,GAC/Da,EAAQE,mBAAmBJ,EAAgBC,GAC3CC,EAAQG,SAASJ,cAEdhB,EAAKG,WACRc,EAAQG,SAASb,EAAME,OAAO,SAACL,EAAOM,UAASN,EAAQM,EAAKN,OAAO,WAGhEa,kDAmBFnH,2CAIAA,sCAGAuH,eACFjB,MAAQiB,EACNvH,gDAGUwF,eACZgB,gBAAkBhB,EAChBxF,kDAIAA,KAAKwG,0DAINgB,EAAW,CACfrB,KAAMnG,KAAKmG,SAETnG,KAAKG,OAAS+F,EAAKE,kBACQ,IAAzBpG,KAAKwG,uBACPgB,EAASJ,SAAWpH,KAAKwG,gBACzBgB,EAASC,KAAO,KAChBD,EAASlB,MAAQtG,KAAKsG,MACfkB,OAEJ,GAAIxH,KAAKG,OAAS+F,EAAKG,kBAC5BmB,EAASlB,MAAQtG,KAAKsG,MACfkB,SAEF,cAIXtB,GAAKE,cAAgB,sBACrBF,GAAKG,WAAa,0BCtFGqB,yBACP5D,EAAM6D,aACI,iBAAT7D,QACJ8D,SAAU,OACVC,SAAW/D,SAIXU,QAAUV,EAAKU,aACfV,KAAOA,OACPgE,SAAWhE,EAAKgE,cAGhBC,SAAWjE,EAAKiE,cAChBC,aAAelE,EAAKkE,kBACpB1C,WAAaxB,EAAKwB,gBAClB2C,cAAgBnE,EAAKmE,mBACrBC,UAAYpE,EAAKoE,eACjBC,YAAcrE,EAAKqE,iBACnBxD,OAASb,EAAKa,aAEhBgD,SAAWA,6DAITS,QAAQpI,KAAK4H,UAAmC,kBAAvB5H,KAAK8D,KAAKuE,iDAInCD,QAAQpI,KAAK4H,oDAIY,aAAzB5H,KAAK8D,KAAKwE,+CAGPX,QACLA,SAAWA,uCAIZ3H,KAAK4H,eACP3I,4CAEIe,KAAK6H,mEAGF,uBAGQ7H,KAAK8D,KAAKuE,cAGpB,cACI,YACJ,mBACI,iBACJ,sBACI,+BAEPpJ,EAAO,oCACA,2CAIAO,OACNQ,KAAK2H,cACF,uCAED3H,KAAK2H,SAASY,aAAavI,KAAMR,sCAG/BA,OACJQ,KAAK2H,cACF,uCAED3H,KAAK2H,SAASa,WAAWxI,KAAMR,sCAG7BA,OACJQ,KAAK2H,cACF,uCAED3H,KAAK2H,SAASc,WAAWzI,KAAMR,qCAG9BA,OACHQ,KAAK2H,cACF,uCAED3H,KAAK2H,SAASe,UAAU1I,KAAMR,YCtFpBmJ,wFACVnJ,QACFK,OAASL,8OAKAA,UAEZA,aAAeD,EAAgBC,EAAM,IAAID,EAAcC,+HAS7CoJ,qNAITf,OACG/D,EAAO9D,KAAK6I,OACd7I,KAAK6I,OAAOC,QAAQjB,GACpB,IAAIH,GAAKG,UACb/D,EAAKiF,YAAY/I,MACV8D,yCAGMA,EAAMkF,OACbhB,EAAelE,EAAKkE,gBAEtBlE,EAAKmF,oBACPhK,sBAAoB6E,EAAKgE,iCAClB,CACLpC,UAAWsC,EACX/D,UAAU,MAIVH,EAAKiE,eACA,CACLrC,UAAWsC,EACX/D,UAAU,OAMT+E,QACI,CACLtD,UAAWsC,EACX/D,UAAU,OAIR7D,EAAK4I,EAAWE,QAChBC,EAAWrF,EAAKoE,UAAU9H,MAE5B+I,EAAU,KACNzD,EAAY5B,EAAKmE,cAAckB,EAASjE,mBACvC,CACLQ,UAAWA,EACXzB,UAAWyB,EAAUD,eACrB2D,cAAc,WAIZ5J,EAAMwJ,EAAWK,eACjBC,EAAkC,eAAnBxF,EAAKyF,UACpBpB,EAAcrE,EAAKqE,YACrBzC,EAAY,KACZzB,GAAW,EAENG,EAAI,EAAGA,EAAI+D,EAAYpH,OAAQqD,IAAK,KAErCoF,EADI,IAAIjH,EAAW4F,EAAY/D,IAChBqF,cACnBjK,EACAQ,KAAK6I,OAAOa,SACZ5F,EACAwF,MAEFrF,EAAWA,GAAYuF,EAAWvF,SAC9BuF,EAAW9D,UAAW,CACxBA,EAAY8D,EAAW9D,uBAKpB,CACLA,UAAWA,GAAasC,EACxB/D,SAAUA,+CAIM0F,EAAQC,UACtBD,EAAOP,aACFO,EAGLC,EAAOR,aACFQ,EAGJD,EAAOjE,UAAUD,eAIjBmE,EAAOlE,UAAUD,eAIfkE,EAHEC,EAJAD,uCAUE7F,EAAMkF,EAAYa,EAAOC,OAC9BtK,EAAMwJ,EAAWK,qBAChB,CACLvF,KAAMA,EAAKgE,SACX3H,KAAMX,EAAIW,KACVC,GAAIZ,EAAIY,GACRsF,UAAWmE,EAAMnE,UAAUoC,SAC3BgC,aAAcA,EACd7F,SAAU4F,EAAM5F,SAChB8F,aAAa,IAAIvG,MAAOwC,oDAIflC,EAAMtE,OACXoH,EAAO,IAAIV,GAAK,0BAA2BA,GAAKE,eACtDQ,EAAKoD,QACLxK,EAAMA,GAAOQ,KAAKH,WAEZmJ,EAAahJ,KAAKiK,gBAAgBzK,OACnCwJ,EAAWvJ,WAAaqE,EAAKoG,wBACzB,UAGHC,EAAanK,KAAKoK,eAAetG,EAAMkF,GACvCqB,EAAkBrK,KAAKoK,eAAetG,EAAMkF,EAAWsB,YAEvDC,EAAkBvK,KAAKwK,oBAC3BL,EACAE,GAGII,EAAOzK,KAAK0K,aAChB5G,EACAkF,EACAuB,EACA,6BAEGI,cAAcF,GAEnB7D,EAAKgE,YACAC,UAAUjE,GACR2D,EAAgB7E,UAAUoF,QAC5BhH,EAAKkE,cAAgBlE,EAAKkE,aAAaF,UAAa,MACrDyC,EAAgB7E,UAAUoC,4CAGrBhE,EAAMtE,OACToH,EAAO,IAAIV,GAAK,wBAAyBA,GAAKE,eACpDQ,EAAKoD,QACLxK,EAAMA,GAAOQ,KAAKH,WACZmJ,EAAahJ,KAAKiK,gBAAgBzK,OACnCwJ,EAAWvJ,WAAaqE,EAAKoG,yBACzB,SAGHC,EAAanK,KAAKoK,eAAetG,EAAMkF,GACvCqB,EAAkBrK,KAAKoK,eAAetG,EAAMkF,EAAWsB,YAEvDC,EAAkBvK,KAAKwK,oBAC3BL,EACAE,GAGII,EAAOzK,KAAK0K,aAChB5G,EACAkF,EACAuB,EACA,2BAEGI,cAAcF,GAEnB7D,EAAKgE,YACAC,UAAUjE,GACR2D,EAAgB7E,UAAUoF,QAC5BhH,EAAKkE,cAAgBlE,EAAKkE,aAAa+C,SAAY,KACpDR,EAAgB7E,UAAUqF,2CAGrBjH,EAAMtE,OACToH,EAAO,IAAIV,GAAK,wBAAyBA,GAAKE,eACpDQ,EAAKoD,QACLxK,EAAMA,GAAOQ,KAAKH,WAEZmJ,EAAahJ,KAAKiK,gBAAgBzK,OACnCwJ,EAAWvJ,WAAaqE,EAAKoG,yBACzB,MAGHC,EAAanK,KAAKoK,eAAetG,EAAMkF,GACvCqB,EAAkBrK,KAAKoK,eAAetG,EAAMkF,EAAWsB,YAEvDC,EAAkBvK,KAAKwK,oBAC3BL,EACAE,GAGII,EAAOzK,KAAK0K,aAChB5G,EACAkF,EACAuB,EACA,2BAEGI,cAAcF,GAEnB7D,EAAKgE,YACAC,UAAUjE,GACR2D,EAAgBtG,2CAGfH,EAAMtE,OACRoH,EAAO,IAAIV,GAAK,uBAAwBA,GAAKE,eACnDQ,EAAKoD,QACLxK,EAAMA,GAAOQ,KAAKH,WAEZmJ,EAAahJ,KAAKiK,gBAAgBzK,OACnCwJ,EAAWvJ,WAAaqE,EAAKoG,yBACzB,MAGHC,EAAanK,KAAKoK,eAAetG,EAAMkF,GACvCqB,EAAkBrK,KAAKoK,eAAetG,EAAMkF,EAAWsB,YAEvDC,EAAkBvK,KAAKwK,oBAC3BL,EACAE,GAGII,EAAOzK,KAAK0K,aAChB5G,EACAkF,EACAuB,EACA,0BAEGI,cAAcF,GAEnB7D,EAAKgE,YACAC,UAAUjE,IACP2D,EAAgB7E,UAAUD,wBClQhCuF,GACJ,WAAYnE,EAAK3D,gBACX,MAAO2D,OACH,wDAEJ,MAAO3D,OACH,4DAEH2D,IAAMA,OACN3D,MAAQA,OACR+H,KAAO,UACPC,KAAO,MAIKC,yBACPC,kBACLC,KAAO,OAELD,MADc,iBAAVA,EACIA,EAEA,QAEV5K,IAAM,QACN8K,KAAO,UACPC,KAAO,+CAGNC,GACNA,EAAKN,KAAOlL,KAAKsL,MACjBE,EAAKP,KAAO,QACRjL,KAAKsL,YACFA,KAAKL,KAAOO,QAEdF,KAAOE,EACM,OAAdxL,KAAKuL,YACFA,KAAOC,QAETH,YACA7K,IAAIgL,EAAK3E,KAAO2E,8BAGnB3E,EAAK3D,OACDsI,EAAO,IAAIR,GAAQnE,EAAK3D,GAC1BlD,KAAKQ,IAAIqG,SACNrG,IAAIqG,GAAK3D,MAAQsI,EAAKtI,WACtBuI,OAAOD,EAAK3E,MAEb7G,KAAKqL,MAAQrL,KAAKoL,eACbpL,KAAKQ,IAAIR,KAAKuL,KAAK1E,UACrBwE,YACAE,KAAOvL,KAAKuL,KAAKN,UACjBM,KAAKL,KAAO,WAGhBQ,QAAQF,+BAGX3E,MACE7G,KAAKQ,IAAIqG,GAAM,KACX3D,EAAQlD,KAAKQ,IAAIqG,GAAK3D,MACtBsI,EAAO,IAAIR,GAAQnE,EAAK3D,eACzBuI,OAAO5E,QACP6E,QAAQF,GACNtI,SAGA,oCAIJ2D,OACC2E,EAAOxL,KAAKQ,IAAIqG,GACJ,OAAd2E,EAAKP,KACPO,EAAKP,KAAKC,KAAOM,EAAKN,UAEjBI,KAAOE,EAAKN,KAED,OAAdM,EAAKN,KACPM,EAAKN,KAAKD,KAAOO,EAAKP,UAEjBM,KAAOC,EAAKP,YAEZjL,KAAKQ,IAAIqG,QACXwE,yCAGGD,QACHC,KAAO,OACP7K,IAAM,QACN8K,KAAO,UACPC,KAAO,KACS,iBAAVH,SACJA,MAAQA,mCAITO,WACFH,EAAOxL,KAAKsL,KACZlH,EAAI,EACDoH,GACLG,EAASH,EAAMpH,GACfA,IACAoH,EAAOA,EAAKN,cCtGGU,yBACPC,kBACLA,WAAaA,OACbC,cAAgB9L,KAAK+L,kBAAkB/L,KAAK6L,gEAGjCA,WACVrL,EAAM,GAENwL,EAAQH,EAAWG,MAEhB5H,EAAI,EAAGA,EAAI4H,EAAMjL,OAAQqD,IAAK,KAC/BN,EAAOxD,EAAc,GAAI0L,EAAM5H,OACf,kBAAlBN,EAAKuE,UAAoD,aAApBvE,EAAKwE,oBAKxCJ,EAAYpE,EAAKoE,UACjB+D,EAAe,GAEZC,EAAI,EAAGA,EAAIhE,EAAUnH,OAAQmL,IAAK,KACnC/C,EAAWjB,EAAUgE,GAE3BD,YAAgB9C,EAASnF,uBAAcmF,EAASgD,WAAchD,EAGhErF,EAAKoE,UAAY+D,UAEX3G,EAAaxB,EAAKwB,WAClB2C,EAAgB,GAClBD,EAAe,KAEVoE,EAAI,EAAGA,EAAI9G,EAAWvE,OAAQqL,IAAK,KACpC1G,EAAYJ,EAAW8G,IAE7BnE,EAAcvC,EAAUR,aAAeQ,GAEzBD,iBACZuC,EAAetC,GAInB5B,EAAKwB,WAAaA,EAClBxB,EAAKmE,cAAgBA,EACrBnE,EAAKkE,aAAeA,EAEpBxH,EAAIsD,EAAKgE,UAAY,IAAIJ,GAAK5D,QAjC5BtD,EAAIsD,EAAKgE,UAAY,IAAIJ,GAAK5D,UAoC3BtD,oDAID6L,EAAUrM,KAAK6L,WAAWQ,eAC5BA,EACKA,EAAQC,wBAEV,+DAIDD,EAAUrM,KAAK6L,WAAWQ,eAC5BA,EACKA,EAAQE,gCAEV,wDAIDF,EAAUrM,KAAK6L,WAAWQ,eAC5BA,EACsC,IAAjCA,EAAQG,uBAEV,+DAIDH,EAAUrM,KAAK6L,WAAWQ,eAC5BA,EAC8C,IAAzCA,EAAQI,+BAEV,0DAIDJ,EAAUrM,KAAK6L,WAAWQ,eAC5BA,GAAwD,kBAAtCA,EAAQK,0BACrBL,EAAQK,0BAEV,wDAIDL,EAAUrM,KAAK6L,WAAWQ,eAC5BA,GAAsD,kBAApCA,EAAQM,wBACrBN,EAAQM,wBAEV,4DAIDN,EAAUrM,KAAK6L,WAAWQ,eAC5BA,GAA0D,kBAAxCA,EAAQO,4BACrBP,EAAQO,4BAEV,wDAIDP,EAAUrM,KAAK6L,WAAWQ,eAC5BA,GAAsD,kBAApCA,EAAQQ,wBACrBR,EAAQQ,wBAEV,qCAGDhF,UACC7H,KAAK8L,cAAcjE,IAAa,IAAIH,GAAKG,2CAIzC7H,KAAK6L,WAAWhI,yDAIS,OAAzB7D,KAAK0J,SAASoD,gBCxGnBC,aADa,sDAWEC,0BACPC,sDAGLA,mBAAqBA,IACrBC,0CAL4BvE,2CAS5BwE,kBAZ2B,SAa3BC,kBAAoBC,SAIlBF,kBAhBiC,OAiBjCC,kBAAoBE,UAGtBC,QAAU,QACV9G,MAAQ,QACR+G,UAAY,QACZxB,MAAQ,WACRyB,SAAW,WAEXC,eAAiB,IAAIvC,GAAI,UACzBwC,gBAAiB,OAEjBC,qBAAsB,OACtBC,mBAAoB,OACpBC,uBAAwB,OACxBC,mBAAoB,8DAMrB/N,KAAKgO,iBACPC,cAAcjO,KAAKgO,sBAGhBA,gBAAkBE,YAAY,WACjCC,EAAKC,aAAY,IAChBpO,KAAKoN,2KAGQiB,kCACXrO,KAAK4N,2BACHL,QAAU,IAGZvN,KAAK6N,yBACHpH,MAAQ,IAGVzG,KAAK8N,6BACHN,UAAY,IAGdxN,KAAK+N,yBACH/B,MAAQ,OAGXsC,EACFD,GACCrO,KAAKuN,QAAQxM,QAAUf,KAAKmN,mBAC3BnN,KAAKyG,MAAM1F,QAAUf,KAAKmN,mBAC1BnN,KAAKwN,UAAUzM,QAAUf,KAAKmN,mBACZ,EAAlBnN,KAAKgM,MAAMX,KAEXrL,KAAK2N,iBACPW,EAAeA,GAAsC,EAAtBtO,KAAKuN,QAAQxM,YACvC4M,gBAAkBW,GAIC,IAAxBtO,KAAKuN,QAAQxM,QACS,IAAtBf,KAAKyG,MAAM1F,QACe,IAA1Bf,KAAKwN,UAAUzM,QACK,IAApBf,KAAKgM,MAAMX,OAEXiD,GAAe,GAGbA,SACIf,EAAUvN,KAAKuN,QACf9G,EAAQzG,KAAKyG,MACb+G,EAAYxN,KAAKwN,WACjBxB,EAAQuC,EAAWvO,KAAKgM,QACxBwC,QAAQ,SAAA3G,GACZ4G,EAAKhB,SAASiB,IAAI7G,UAGf0F,QAAU,QACV9G,MAAQ,QACR+G,UAAY,QACZxB,MAAQ,gBAEPhM,KAAK2O,YACT3O,KAAK4O,iCAA6C5O,KAAK8M,OACvD+B,EAAe,CACbtB,QAASA,EACT9G,MAAOA,EAAMjG,IAAI,SAAA6B,UAAKA,EAAEyM,gBAAevJ,OAAO,SAAAwJ,UAAa,OAAPA,IACpDvB,UAAWA,EACXxB,MAAOA,EACPK,QAAS,CACPlG,KAAM,KACN6I,oBAGJC,MAAM,SAAAC,GACNjQ,EAAOiQ,uJAKG1P,OACRwJ,EAAaL,GAAYwG,UAAUlF,gBAAgBmF,KAAKpP,KAAMR,OAE/DwJ,EAAWvJ,iBACPuJ,MAEH5I,EAAK4I,EAAWE,QAChBmG,EAAOrG,EAAWsG,UAClBC,EAAavP,KAAK0N,eAAe8B,IAAIpP,UACxB,OAAfmP,GAAuBF,IAASE,QAC7BhC,QAAQxG,KAAKiC,EAAWK,qBAG1BqE,eAAe+B,IAAIrP,EAAIiP,QACvBjB,cAEEpF,+CAIFvC,MAAQP,GAAKwJ,aAAa1P,KAAKyG,yCAG5BG,QACHH,MAAMM,KAAKH,GACZ5G,KAAKyG,MAAM1F,QAAUf,KAAKmN,wBACvBwC,qBAEFvB,oDAGO3D,QACP+C,UAAUzG,KAAK0D,QACf2D,4DAGOxF,+EACPgH,EAAchH,0BACjB3J,EAAO,mGAIT2J,EAAK4F,QAAQ,SAAAhP,GACXqQ,EAAK5F,gBAAgBzK,cAGjBQ,KAAKoO,aAAY,8IAGR0B,yFACQC,MAAMD,iBAAvBE,kBACaA,EAASC,qBAAtBC,2BACCA,+IAGSJ,EAAKI,4FAAMC,iCAAc,mBACjCC,EAAU,CACdC,OAAQ,OACRC,QAAS,gBACSH,mBACEI,OAAOC,WAAWN,IAEtCO,SAAU,SACVC,KAAM7B,EAAeqB,aAEjBH,MAAMD,EAAKM,GAASnB,MAAM,SAAAC,GAC9ByB,OAAO,kQAKQ3Q,KAAK4Q,qBACnB5Q,KAAK4O,uDAA2C5O,KAAK8M,uCADpD4D,2BAGCA,6OAIY1Q,KAAK4Q,qBACnB7D,eAA+B/M,KAAK8M,gCADnC4D,2BAGCA,gIAImB1Q,KAAK6I,OAAOgI,0BAChCC,EAA2B9Q,KAAK6I,OAAOkI,8BAEvCC,GADoBhR,KAAK6I,OAAOoI,uBACLjR,KAAK6I,OAAOqI,+BACvCtD,EAAsB5N,KAAK6I,OAAOsI,yBAClCtD,EAAoB7N,KAAK6I,OAAOuI,uBAChCtD,EAAwB9N,KAAK6I,OAAOwI,2BACpCtD,EAAoB/N,KAAK6I,OAAOyI,uBAME,iBAA7BR,GACoB,EAA3BA,SAEK3D,kBAAoB2D,OACpBS,0BAK+B,iBAA7BP,GACoB,EAA3BA,GACAA,GAA4BhR,KAAKoN,yBAE5BA,kBAAoB4D,OACpBO,0BAqB0B,kBAAxB3D,SACJA,oBAAsBA,GAII,kBAAtBC,SACJA,kBAAoBA,GAIU,kBAA1BC,SACJA,sBAAwBA,GAIE,kBAAtBC,SACJA,kBAAoBA,0DAINyD,EAAUC,4FAEvB7K,EAAO,IAAIV,GAAKsL,EAAUtL,GAAKE,gBAChC4D,iBACgByH,WAAfC,SACA7F,EAAa6F,OACd7I,OAAS,IAAI+C,GAAOC,QACpB8F,YACD3R,KAAKiN,yBACFA,mBAAmBpB,GAE1BjF,EAAKgE,YACAC,UAAUjE,4DAEfzH,QAAQyS,UACR3S,2BAEO,qCAEF,yJAIP6N,0FACA+E,qCACAC,iCA1TuB,gBA4TjBC,EAAc,iBACfjF,EAAOkF,MAAMD,wBACV,mIAGHjF,OAASA,OACT+E,mBAAqBA,OAErBjD,uCAAkCkD,QAClCG,mCAA8BH,QAE9B5E,YAEAgF,QAAS,YAKJlS,KAAKmS,iBACX,wBACAnS,KAAKoS,eAAeC,KAAKrS,2DAILA,KAAKmS,iBACzB,mCACAnS,KAAKsS,qBAAqBD,KAAKrS,oBAF5BkS,0BAMHlS,KAAKkS,YACD,wEAGJL,SACGU,2BACAC,+NAKHxS,KAAKgO,iBACPC,cAAcjO,KAAKgO,sBAGhByE,oBACAC,mCAEC1S,KAAKoO,aAAY,yHAGpBvG,OACG/D,EAAO6E,GAAYwG,UAAUrL,KAAKsL,KAAKpP,KAAM6H,UAC/C/D,EAAK6O,WAEF3S,KAAKyN,SAASmF,IAAI/K,UAChBmE,MAAM0C,IAAI7G,QACVuG,gBAGFtK,uDAIF2O,oBACAI,kBAAoB3E,YAAY,WAGT,IAFd4E,KACCC,EAAKC,yBAA2B,IAC1B,MACjB/T,EACE,uEAEF8T,EAAKR,wBAEN,UAEEU,uBAAyB/E,YAAY,WAGd,IAFd4E,KACCC,EAAKC,yBAA2B,IAC1B,MACjB/T,EACE,8EAEF8T,EAAKZ,iBACH,mCACAY,EAAKT,qBAAqBD,KAAKU,IAC/BG,KACA,kBAAMjU,EAAO,uCACb,kBAAMA,EAAO,kDAGhB,4CAICe,KAAK6S,oBACP5E,cAAcjO,KAAK6S,0BACZ7S,KAAK6S,kBAER7S,KAAKgT,gCACAhT,KAAKgT,yBAIZhT,KAAKiT,yBACPhF,cAAcjO,KAAKiT,+BACZjT,KAAKiT,sFAKTP,+BAEAS,YAAc,IAAIC,YAClBpT,KAAKiS,yDAAkDjS,KAAK8M,8BAE5DqG,YAAYE,iBAAiB,mBAAoB,SAAAC,OAC9CzH,EAAa0H,KAAKC,MAAMF,EAAIpD,MAClCuD,EAAK5K,OAAS,IAAI+C,GAAOC,GACzB4H,EAAK9B,YACD8B,EAAKxG,oBACPwG,EAAKxG,mBAAmBpB,GAE1B4H,EAAKT,wBAA0BF,WAG5BK,YAAYE,iBAAiB,YAAa,WAC7CI,EAAKT,wBAA0BF,wDAK7B9S,KAAKmT,mBACFA,YAAYO,eACV1T,KAAKmT,sBCxbZQ,YACHxS,EAAmB,MAAQ,CAC1BK,EACAC,EACAC,EACAC,UPxByB,MO0BV,MAAQ,CACvBH,EACAC,EACAC,EACAC,EACAC,EACAC,EACAC,EACAC,UAEDX,EAAkB,MAAQ,CACzBI,EACAC,EACAC,EACAC,EACAC,EACAC,EACAC,EACAC,UAEDV,EAAoB,MAAQ,CAACG,EAAkBC,UAC/CH,EAAiB,MAAQ,CACxBE,EACAC,EACAC,EACAC,EACAK,EACAC,EACAC,EACAC,UAEDZ,EAAqB,MAAQ,CAC5BC,EACAC,EACAC,EACAC,EACAK,EACAC,EACAC,EACAC,SAISyR,GAAsB,SAAAC,WAK3B7H,EAAQ,GACR8H,EAAOC,EAAYF,cAChBzP,OACDyC,EAAMiN,EAAK1P,GACX4P,EAASH,EAAWhN,GAEpBoN,EAAW,CACf5L,SAAU,QACV7D,QAASqC,EACTkB,gBAJ+BnH,IAAlBoT,EAAOE,QAAuBF,EAAOE,QAKlDC,mBACArM,SAAUjB,EACVyB,WAAY,eAER8L,EAAYJ,EAAOI,WAAa,GAChCC,EAAYL,EAAOK,WAAa,GAChCC,EAAe,MAAQD,GACvBE,EAAoBH,EAAU7O,OAAO,SAAAnB,UAAMkQ,EAAa1B,IAAIxO,QAElE6P,EAAS3O,WAAa,CACpB,CACEJ,YAAa,gBACb4C,SAAU,MACV0M,WAAW,EACX/O,gBAAgB,GAElB,CACEP,YAAa,eACb4C,SAAU,KACV0M,WAAW,EACX/O,gBAAgB,IAIpBwO,EAAS/L,UAAY,GAErB+L,EAAS/L,UAAY+L,EAAS/L,UAAUuM,OACtCF,EAAkB/T,IAAI,SAAA4D,SAAM,CAC1Bc,YAAa,eACblB,WAAY,OACZmI,SAAU/H,EAAEsQ,eAIhBT,EAAS/L,UAAY+L,EAAS/L,UAAUuM,OACtCJ,EAAU7T,IAAI,SAAA4D,SAAM,CAClBc,YAAa,gBACblB,WAAY,OACZmI,SAAU/H,EAAEsQ,eAIhBT,EAAStP,OAAS,CAAC,CAACO,YAAa,eAAgBR,WAAY,IAEzDsP,EAAOxR,WAAY,SACf0B,EAAQ8P,EAAOxR,YAAc,GAC7BmS,EAAY,GAETzI,EAAI,EAAGA,EAAIhI,EAAMnD,OAAQmL,IAAK,KAC/B7H,EAAIH,EAAMgI,GACZ/L,YACAyP,EAAcvL,EAAEnB,OAAQ,KACpB0R,EAAQ,MACZvQ,EAAEnB,MAAM1C,IAAI,SAAAoC,UAAKL,EAAWO,oBAAoBF,SAGhC,GAAdgS,EAAMvJ,YACRpM,EACE,2JAEK,MAGTkB,EAAOoO,EAAWqG,GAAO,QAEzBzU,EAAOoC,EAAWO,oBAAoBuB,EAAEnB,WAGpC2R,EAAQ,CACZlS,cAAe0B,EAAEyQ,UACjBjS,cAAe1C,EACfmD,SAAUe,EAAEf,SACZJ,MAAQ0M,EAAcvL,EAAEnB,OAAmB,KAAVmB,EAAEnB,MACnCE,UAAYwM,EAAcvL,EAAEnB,OAAgBmB,EAAEnB,MAAT,UAGlCyQ,GAA+BxT,GAAMyS,IAAIvO,EAAEf,iBAC9CrE,0CAEIoF,EAAEf,sDACmCnD,WAElC,SAGL0U,EAAMzR,cAENyR,EAAMvR,WAAa5B,GACnBmT,EAAMvR,WAAa3B,SAEnB1C,EACE,sFAEK,cAIP4V,EAAMvR,WAAa5B,GACnBmT,EAAMvR,WAAa3B,SAEnB1C,EACE,6GAEK,MAIX0V,EAAU5N,KAAK8N,GAGjBZ,EAAS9L,YAAc,CACrB,CACE3D,QAAS,eACTR,WAAY,OACZU,WAAYsP,EAAOe,QAAU,EAC7B7Q,MAAOyQ,EACP/P,UAAW,UAIfqP,EAAS9L,YAAc,CACrB,CACE3D,QAAS,eACTR,WAAY,OACZU,WAAYsP,EAAOe,QAAU,EAC7B7Q,MAAO,GACPU,UAAW,KAKjBoH,EAAMjF,KAAKkN,IA3IJ7P,EAAI,EAAGA,EAAI0P,EAAK/S,OAAQqD,IAAK,SAA7BA,uCA8IF,CACL4H,MAAOA,EACPnI,IAAK,CACHW,QAAS,QACTsI,OAAQ,QC9NOkI,iGAAarM,uDAChBkL,0EAEK,QADbhI,EAAa+H,GAAoBC,SAE/B,4FAEHhL,OAAS,IAAI+C,GAAOC,sGCNvBoJ,GAAa,IAAID,GACvBC,GAAWC,UAAU,QAERC,GAAb,uCAESC,oBAAsB,qEAOfxM,oEACR5I,KAAKqV,4BACDrV,KAAKqV,YAAYC,QAAQ1M,oDAEzB,4MAKMwH,gFACT+E,EAAYI,QAAQnF,wBACjB,yCAGFtD,EAASsD,EAAQtD,OACjB+G,EAAazD,EAAQyD,WAEtB/G,GAAW+G,uBACR,8HAGFhC,GAC2B,IAA/BzB,EAAQyB,oBAEN/E,sBAEA9M,KAAKqV,aACLrV,KAAKqV,YAAYvI,SAAWA,GAC5B9M,KAAKqV,YAAYxD,qBAAuBA,GACxC7R,KAAKqV,YAAYG,qBAChBxV,KAAKqV,YAAYnD,wBAEZlS,KAAKqV,YAAYG,sEAEnBxV,KAAKqV,6BACDrV,KAAKqV,YAAYI,+CAEpBJ,YAAc,IAAIrI,GAAQhN,KAAK0V,uBAAuBrD,KAAKrS,OAC1D2V,EAAU3V,KAAKqV,YAAYH,UAC/BpI,EACAsD,EAAQyB,mBACRzB,EAAQ0B,gBAELuD,YAAYG,mBAAqBG,YAChCA,qCAGJ3V,KAAKqV,6BACDrV,KAAKqV,YAAYI,+CAEpBJ,YAAc,IAAIL,aACjBhV,KAAKqV,YAAYH,UAAUrB,gNAK/B7T,KAAKqV,4BACDrV,KAAKqV,YAAYI,wCAChBzV,KAAKqV,uCAEN,yLAILxN,UACK7H,KAAKqV,aAAeJ,IAAYnR,KAAK+D,4CAG9B+N,GX9EjB3W,EW+EY2W,iDAGW/J,QAChBuJ,oBAAoB5G,QAAQ,SAAAqH,UAAYA,EAAShK,mDAGlCgK,QACfT,oBAAoBrO,KAAK8O,oDAGPA,QAClBT,oBAAsBpV,KAAKoV,oBAAoB7P,OAClD,SAAAuQ,UAAKA,IAAMD,qCAINrW,OACHQ,KAAKqV,iBAKD,wEAJDA,YAAYU,SAASvW,QACrB6V,YAAYpL,gBAAgBzK,QAC5B6V,YAAYjH,aAAY,qCA9FlB5O,UACNA,MAAAA,GAAqCA,EAAIwW,cAAgBC,aANpE,GA0GMC,GAAU,IAAIf,UChHpB7U,EAAc0M,GAAS,CAACmI,YAAAA"}