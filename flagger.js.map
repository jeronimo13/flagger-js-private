{"version":3,"file":"flagger.js","sources":["src/logger.js","src/object.js","src/population.js","src/stat.js","src/flag.js","src/environment.js","src/lru.js","src/router.js","src/airship.js","src/transformers/core_transformer.js","src/core.js","src/index.js","src/index-umd.js"],"sourcesContent":["export let logger = x => {\n  // eslint-disable-next-line no-console\n  console.error(x)\n}\n\nexport function setLogger(fn) {\n  logger = fn\n}\n","import md5 from 'md5'\nimport {logger} from './logger'\nimport stringify from 'fast-json-stable-stringify'\n\nconst validate = obj => {\n  if (!obj) {\n    return false\n  }\n  return true\n}\n\nexport const DEFAULT_ENTITY_TYPE = 'User'\n\nexport default class AirshipObject {\n  constructor(obj) {\n    let isValid = AirshipObject.isValidObject(obj)\n\n    if (!isValid) {\n      this.object = null\n      return\n    }\n\n    obj = AirshipObject._cloneObject(obj)\n    isValid = AirshipObject._fillInFields(obj)\n\n    if (!isValid) {\n      this.object = null\n      return\n    }\n\n    this.object = obj\n  }\n\n  static isValidObject(obj) {\n    let isValid = validate(obj)\n    if (!isValid) {\n      // logger(validate.errors.map(e => e.message))\n    }\n\n    if (isValid) {\n      const isGroup = obj.isGroup !== undefined ? obj.isGroup : false\n      const type = obj.type !== undefined ? obj.type : DEFAULT_ENTITY_TYPE\n\n      const groupIndex = type.lastIndexOf('Group')\n      if (\n        groupIndex !== -1 &&\n        groupIndex === type.length - 'Group'.length &&\n        !isGroup\n      ) {\n        logger(\n          \"An entity's type that ends with `Group` must be a group entity and therefore has to have an explicit `isGroup: true` property\"\n        )\n        isValid = false\n      }\n    }\n\n    return isValid\n  }\n\n  static _cloneObject(obj) {\n    const clone = Object.assign({}, obj)\n\n    if (obj.attributes !== undefined) {\n      clone.attributes = Object.assign({}, obj.attributes)\n    }\n\n    if (obj.group !== undefined) {\n      clone.group = Object.assign({}, obj.group)\n\n      if (obj.group.attributes !== undefined) {\n        clone.group.attributes = Object.assign({}, obj.group.attributes)\n      }\n    }\n\n    return clone\n  }\n\n  static _fillInFields(obj) {\n    if (obj.type === undefined) {\n      obj.type = DEFAULT_ENTITY_TYPE\n    }\n\n    if (obj.displayName === undefined) {\n      obj.displayName = '' + obj.id\n    }\n\n    if (obj.isGroup === undefined) {\n      obj.isGroup = false\n    }\n\n    if (Number.isInteger(obj.id)) {\n      const idStr = '' + obj.id\n      if (idStr.length > 250) {\n        logger('Integer id must have 250 digits or less')\n        return false\n      }\n      obj.id = idStr\n    }\n\n    let group = null\n    if (obj.group !== undefined) {\n      group = obj.group\n    }\n\n    if (group !== null && group.displayName === undefined) {\n      group.displayName = '' + group.id\n    }\n\n    if (group !== null && group.type === undefined) {\n      group.type = obj.type + 'Group'\n    }\n\n    if (group !== null) {\n      group.isGroup = true\n    }\n\n    if (group !== null) {\n      if (Number.isInteger(group.id)) {\n        const idStr = '' + group.id\n        if (idStr.length > 250) {\n          logger('Integer id must have 250 digits or less')\n          return false\n        }\n        group.id = idStr\n      }\n    }\n\n    return true\n  }\n\n  getHash() {\n    return md5(\n      stringify({\n        ...this.object,\n        attributes: this.object.attributes || {},\n        group: {\n          ...this.object.group,\n          attributes: (this.object.group && this.object.group.attributes) || {}\n        }\n      })\n    )\n  }\n\n  getId() {\n    const obj = this.object\n    return `${obj.type}_${obj.id}`\n  }\n\n  isValid() {\n    return this.object !== null\n  }\n\n  getRawObject() {\n    return this.object\n  }\n\n  getObject() {\n    const obj = this.object\n    const clone = Object.assign({}, obj)\n    delete clone.group\n    return new AirshipObject(clone)\n  }\n\n  getGroup() {\n    const group = this.object.group || null\n    return group && new AirshipObject(group)\n  }\n}\n","import md5 from 'md5'\nimport {logger} from './logger'\n\nexport const RULE_TYPE_STRING = 'string'\nexport const RULE_TYPE_INT = 'int'\nexport const RULE_TYPE_FLOAT = 'float'\nexport const RULE_TYPE_BOOLEAN = 'boolean'\nexport const RULE_TYPE_DATE = 'date'\nexport const RULE_TYPE_DATETIME = 'datetime'\n\nexport const RULE_OPERATOR_IS = 'is'\nexport const RULE_OPERATOR_IS_NOT = 'is_not'\nexport const RULE_OPERATOR_IN = 'in'\nexport const RULE_OPERATOR_NOT_IN = 'not_in'\nexport const RULE_OPERATOR_LT = 'lt'\nexport const RULE_OPERATOR_LTE = 'lte'\nexport const RULE_OPERATOR_GT = 'gt'\nexport const RULE_OPERATOR_GTE = 'gte'\nexport const RULE_OPERATOR_FROM = 'from'\nexport const RULE_OPERATOR_UNTIL = 'until'\nexport const RULE_OPERATOR_AFTER = 'after'\nexport const RULE_OPERATOR_BEFORE = 'before'\n\nexport const getHashedValue = s => {\n  return (parseInt(md5(s), 16) * 1.0) / 340282366920938463463374607431768211455\n}\n\nexport default class Population {\n  constructor(population) {\n    this.population = population\n  }\n\n  static categorizeValueType(v) {\n    if (v === true || v === false) {\n      return 'boolean'\n    } else if (typeof v === 'number') {\n      if ((v + '').indexOf('.') >= 0) {\n        return 'float'\n      } else {\n        return 'int'\n      }\n    } else if (typeof v === 'string') {\n      const unixTimestamp = new Date(v).getTime()\n\n      if (!isNaN(unixTimestamp)) {\n        const isoFormat = new Date(v).toISOString()\n        const timeIndex = isoFormat.lastIndexOf('T00:00:00.000Z')\n        if (\n          timeIndex !== -1 &&\n          isoFormat.length - 'T00:00:00.000Z'.length === timeIndex\n        ) {\n          return 'date'\n        } else {\n          return 'datetime'\n        }\n      }\n\n      return 'string'\n    }\n    logger('Unexpected attribute value type encountered')\n    return null\n  }\n\n  _ruleMatches(rule, obj) {\n    const attributes = obj.attributes || {}\n\n    if (!attributes.hasOwnProperty(rule.attributeName)) {\n      return false\n    }\n\n    const v = attributes[rule.attributeName]\n    const attributeType = Population.categorizeValueType(v)\n\n    const numberTypes = [RULE_TYPE_INT, RULE_TYPE_FLOAT]\n\n    if (\n      numberTypes.indexOf(attributeType) !== -1 &&\n      numberTypes.indexOf(rule.attributeType) !== -1\n    ) {\n      // This is fine\n    } else if (attributeType !== rule.attributeType) {\n      return false\n    }\n\n    const targetVal = rule.value\n    const targetValList = rule.valueList\n    const op = rule.operator\n\n    if (attributeType === RULE_TYPE_STRING) {\n      if (op === RULE_OPERATOR_IS) {\n        return v === targetVal\n      } else if (op === RULE_OPERATOR_IS_NOT) {\n        return v !== targetVal\n      } else if (op === RULE_OPERATOR_IN) {\n        return targetValList.indexOf(v) !== -1\n      } else if (op === RULE_OPERATOR_NOT_IN) {\n        return targetValList.indexOf(v) === -1\n      } else {\n        logger('Invalid rule operator encountered')\n        return false\n      }\n    } else if (numberTypes.indexOf(attributeType) !== -1) {\n      if (op === RULE_OPERATOR_IS) {\n        return v === targetVal\n      } else if (op === RULE_OPERATOR_IS_NOT) {\n        return v !== targetVal\n      } else if (op === RULE_OPERATOR_IN) {\n        return targetValList.indexOf(v) !== -1\n      } else if (op === RULE_OPERATOR_NOT_IN) {\n        return targetValList.indexOf(v) === -1\n      } else if (op === RULE_OPERATOR_LT) {\n        return v < targetVal\n      } else if (op === RULE_OPERATOR_LTE) {\n        return v <= targetVal\n      } else if (op === RULE_OPERATOR_GT) {\n        return v > targetVal\n      } else if (op === RULE_OPERATOR_GTE) {\n        return v >= targetVal\n      } else {\n        logger('Invalid rule operator encountered')\n        return false\n      }\n    } else if (attributeType === RULE_TYPE_BOOLEAN) {\n      if (op === RULE_OPERATOR_IS) {\n        return v === targetVal\n      } else if (op === RULE_OPERATOR_IS_NOT) {\n        return v !== targetVal\n      } else {\n        logger('Invalid rule operator encountered')\n        return false\n      }\n    } else if (\n      attributeType === RULE_TYPE_DATE ||\n      attributeType === RULE_TYPE_DATETIME\n    ) {\n      const targetTime = targetVal && new Date(targetVal).getTime()\n      const targetTimeList =\n        targetValList && targetValList.map(tv => new Date(tv).getTime())\n      const vTime = new Date(v).getTime()\n\n      if (op === RULE_OPERATOR_IS) {\n        return vTime === targetTime\n      } else if (op === RULE_OPERATOR_IS_NOT) {\n        return vTime !== targetTime\n      } else if (op === RULE_OPERATOR_IN) {\n        return targetTimeList.indexOf(vTime) !== -1\n      } else if (op === RULE_OPERATOR_NOT_IN) {\n        return targetTimeList.indexOf(vTime) === -1\n      } else if (op === RULE_OPERATOR_FROM) {\n        return vTime >= targetTime\n      } else if (op === RULE_OPERATOR_UNTIL) {\n        return vTime <= targetTime\n      } else if (op === RULE_OPERATOR_AFTER) {\n        return vTime > targetTime\n      } else if (op === RULE_OPERATOR_BEFORE) {\n        return vTime < targetTime\n      } else {\n        logger('Invalid rule operator encountered')\n        return false\n      }\n    } else {\n      logger('Invalid attribute type encountered')\n      return false\n    }\n  }\n\n  getGateValues(obj, env, flag, sticky) {\n    const population = this.population\n    if (this.population.entityType !== obj.type) {\n      return {eligible: false}\n    }\n\n    const rules = population.rules\n\n    let matches = true\n\n    for (let i = 0; i < rules.length; i++) {\n      const r = rules[i]\n      matches = matches && this._ruleMatches(r, obj)\n    }\n\n    if (matches) {\n      const samplingHashKey = `SAMPLING:control_${flag.hashKey}:env_${\n        env.hashKey\n      }:rule_set_${this.population.hashKey}:client_object_${obj.type}_${obj.id}`\n\n      const hashedPercentage = getHashedValue(samplingHashKey)\n\n      if (\n        hashedPercentage <= this.population.percentage &&\n        this.population.percentage > 0\n      ) {\n        const splits = sticky\n          ? this.population.universes[\n              Math.max(Math.floor(hashedPercentage * 100) - 1, 0)\n            ]\n          : flag.splits\n        const splitsMap = {}\n        for (let i = 0; i < splits.length; i++) {\n          const split = splits[i]\n          splitsMap[split.treatmentId] = split\n        }\n\n        const allocationHashKey = `DISTRIBUTION:control_${flag.hashKey}:env_${\n          env.hashKey\n        }:client_object_${obj.type}_${obj.id}`\n\n        const allocationHashedPercentage = getHashedValue(allocationHashKey)\n\n        let trailingSum = 0.0\n\n        const treatments = flag.treatments.filter(t => !t.isOffTreatment)\n\n        let treatment = null\n        for (let i = 0; i < treatments.length; i++) {\n          const t = treatments[i]\n          if (splitsMap.hasOwnProperty(t.treatmentId)) {\n            trailingSum = parseFloat(\n              (trailingSum + splitsMap[t.treatmentId].percentage).toFixed(3)\n            )\n\n            if (allocationHashedPercentage <= trailingSum) {\n              treatment = t\n              break\n            }\n          }\n        }\n\n        return {treatment: treatment, eligible: true}\n      } else {\n        return {eligible: true}\n      }\n    } else {\n      return {eligible: false}\n    }\n  }\n}\n","const NS_PER_SEC = 1e9\n\nexport default class Stat {\n  static compactStats(stats) {\n    const groups = stats.reduce((groups, stat) => {\n      const key = [stat.name, stat.type].join(',')\n      groups[key] = groups[key] || []\n      groups[key].push(stat)\n      return groups\n    }, {})\n\n    return Object.values(groups).map(stats => {\n      const newStat = new Stat(stats[0].name, stats[0].type)\n      let totalDuration, totalCount\n      switch (newStat.type) {\n        case Stat.TYPE_DURATION:\n          totalDuration = stats.reduce(\n            (duration, stat) => duration + stat.averageDuration * stat.count,\n            0\n          )\n          totalCount = stats.reduce((count, stat) => count + stat.count, 0)\n          newStat.setAverageDuration(totalDuration / totalCount)\n          newStat.setCount(totalCount)\n          break\n        case Stat.TYPE_COUNT:\n          newStat.setCount(stats.reduce((count, stat) => count + stat.count, 0))\n          break\n      }\n      return newStat\n    })\n  }\n\n  constructor(name, type) {\n    const allowedTypes = [Stat.TYPE_DURATION, Stat.TYPE_COUNT]\n    if (allowedTypes.indexOf(type) === -1) {\n      throw 'Invalid stat type passed'\n    }\n    this.name = name\n    this.type = type\n\n    this.count = 0\n    this.startTime = null\n\n    this.averageDuration = 0\n  }\n\n  start() {\n    return this\n  }\n\n  stop() {\n    return this\n  }\n\n  setCount(n) {\n    this.count = n\n    return this\n  }\n\n  setAverageDuration(t) {\n    this.averageDuration = t\n    return this\n  }\n\n  getDuration() {\n    return this.averageDuration\n  }\n\n  getStatsObj() {\n    const statsObj = {\n      name: this.name\n    }\n    if (this.type === Stat.TYPE_DURATION) {\n      if (this.averageDuration !== 0) {\n        statsObj.duration = this.averageDuration\n        statsObj.unit = 'ns'\n        statsObj.count = this.count\n        return statsObj\n      }\n    } else if (this.type === Stat.TYPE_COUNT) {\n      statsObj.count = this.count\n      return statsObj\n    }\n    return null\n  }\n}\n\nStat.TYPE_DURATION = 'stat_type__duration'\nStat.TYPE_COUNT = 'stat_type__count'\n","import {logger} from './logger'\n\nexport default class Flag {\n  constructor(flag, delegate) {\n    if (typeof flag === 'string') {\n      this._isWild = true\n      this.flagName = flag\n    } else {\n      // These along with flag.flagType and flag.flagStatus\n      // should always be present\n      this.hashKey = flag.hashKey\n      this.flag = flag\n      this.codename = flag.codename\n\n      // Pass through fields\n      this.isPaused = flag.isPaused\n      this.offTreatment = flag.offTreatment\n      this.treatments = flag.treatments\n      this.treatmentsMap = flag.treatmentsMap\n      this.overrides = flag.overrides\n      this.populations = flag.populations\n      this.splits = flag.splits\n    }\n    this.delegate = delegate\n  }\n\n  isUncategorized() {\n    return Boolean(this._isWild) || this.flag.flagType === 'uncategorized'\n  }\n\n  isWild() {\n    return Boolean(this._isWild)\n  }\n\n  isArchived() {\n    return this.flag.flagStatus === 'archived'\n  }\n\n  setDelegate(delegate) {\n    this.delegate = delegate\n  }\n\n  getType() {\n    if (this._isWild) {\n      logger(\n        `Encountered uncategorized flag \"${\n          this.flagName\n        }\". Visit Airship web app to convert it to a real flag`\n      )\n      return 'uncategorized'\n    }\n\n    const flagType = this.flag.flagType\n\n    switch (flagType) {\n      case 'basic':\n        return 'basic'\n      case 'experiment':\n        return 'experiment'\n      case 'uncategorized':\n        return 'uncategorized'\n      default:\n        logger('Unexpected flag type encountered')\n        return null\n    }\n  }\n\n  getTreatment(obj) {\n    if (!this.delegate) {\n      throw 'Delegate not provided to flag'\n    }\n    return this.delegate.getTreatment(this, obj)\n  }\n\n  getPayload(obj) {\n    if (!this.delegate) {\n      throw 'Delegate not provided to flag'\n    }\n    return this.delegate.getPayload(this, obj)\n  }\n\n  isEligible(obj) {\n    if (!this.delegate) {\n      throw 'Delegate not provided to flag'\n    }\n    return this.delegate.isEligible(this, obj)\n  }\n\n  isEnabled(obj) {\n    if (!this.delegate) {\n      throw 'Delegate not provided to flag'\n    }\n    return this.delegate.isEnabled(this, obj)\n  }\n}\n","import {logger} from './logger'\nimport AirshipObject from './object'\nimport Population from './population'\nimport Stat from './stat'\nimport Flag from './flag'\n\nexport default class Environment {\n  identify(obj) {\n    this.object = obj\n  }\n\n  async maybeIngest() {}\n\n  _identifyObject(obj) {\n    const airshipObj =\n      obj instanceof AirshipObject ? obj : new AirshipObject(obj)\n\n    return airshipObj\n  }\n\n  _saveStat() {}\n\n  _saveExposure() {}\n\n  async publish(objs) {} // eslint-disable-line no-unused-vars\n\n  shutdown() {}\n\n  flag(flagName) {\n    const flag = this.router\n      ? this.router.getFlag(flagName)\n      : new Flag(flagName)\n    flag.setDelegate(this)\n    return flag\n  }\n\n  _getAllocation(flag, airshipObj) {\n    const offTreatment = flag.offTreatment\n\n    if (flag.isArchived()) {\n      logger(`The flag \"${flag.codename}\" has been archived`)\n      return {\n        treatment: offTreatment,\n        eligible: false\n      }\n    }\n\n    if (flag.isPaused) {\n      return {\n        treatment: offTreatment,\n        eligible: false\n      }\n    }\n\n    // If the airshipObj is not a valid obj,\n    // then return the offTreatment/false\n    if (!airshipObj) {\n      return {\n        treatment: offTreatment,\n        eligible: false\n      }\n    }\n\n    const id = airshipObj.getId()\n    const override = flag.overrides[id]\n\n    if (override) {\n      const treatment = flag.treatmentsMap[override.treatmentId]\n      return {\n        treatment: treatment,\n        eligible: !treatment.isOffTreatment,\n        fromOverride: true\n      }\n    }\n\n    const obj = airshipObj.getRawObject()\n    const useUniverses = flag.getType() === 'experiment'\n    const populations = flag.populations\n    let treatment = null\n    let eligible = false\n\n    for (let i = 0; i < populations.length; i++) {\n      const p = new Population(populations[i])\n      const gateValues = p.getGateValues(\n        obj,\n        this.router.getEnv(),\n        flag,\n        useUniverses\n      )\n      eligible = eligible || gateValues.eligible\n      if (gateValues.treatment) {\n        treatment = gateValues.treatment\n        break\n      }\n    }\n\n    return {\n      treatment: treatment || offTreatment,\n      eligible: eligible\n    }\n  }\n\n  _resolveAllocations(alloc1, alloc2) {\n    if (alloc1.fromOverride) {\n      return alloc1\n    }\n\n    if (alloc2.fromOverride) {\n      return alloc2\n    }\n\n    if (!alloc1.treatment.isOffTreatment) {\n      return alloc1\n    }\n\n    if (!alloc2.treatment.isOffTreatment) {\n      return alloc2\n    }\n\n    return alloc1\n  }\n\n  _getExposure(flag, airshipObj, alloc, methodCalled) {\n    const obj = airshipObj.getRawObject()\n    return {\n      flag: flag.codename,\n      type: obj.type,\n      id: obj.id,\n      treatment: alloc.treatment.codename,\n      methodCalled: methodCalled,\n      eligible: alloc.eligible,\n      timeExposed: new Date().toISOString()\n    }\n  }\n\n  getTreatment(flag, obj) {\n    const stat = new Stat('duration__get_treatment', Stat.TYPE_DURATION)\n    stat.start()\n    obj = obj || this.object\n\n    const airshipObj = this._identifyObject(obj)\n    if (!airshipObj.isValid() || flag.isUncategorized()) {\n      return 'off'\n    }\n\n    const allocation = this._getAllocation(flag, airshipObj)\n    const groupAllocation = this._getAllocation(flag, airshipObj.getGroup())\n\n    const finalAllocation = this._resolveAllocations(\n      allocation,\n      groupAllocation\n    )\n\n    const expo = this._getExposure(\n      flag,\n      airshipObj,\n      finalAllocation,\n      'get_treatment'\n    )\n    this._saveExposure(expo)\n\n    stat.stop()\n    this._saveStat(stat)\n    return finalAllocation.treatment.isGhost\n      ? (flag.offTreatment && flag.offTreatment.codename) || 'off'\n      : finalAllocation.treatment.codename\n  }\n\n  getPayload(flag, obj) {\n    const stat = new Stat('duration__get_payload', Stat.TYPE_DURATION)\n    stat.start()\n    obj = obj || this.object\n    const airshipObj = this._identifyObject(obj)\n    if (!airshipObj.isValid() || flag.isUncategorized()) {\n      return null\n    }\n\n    const allocation = this._getAllocation(flag, airshipObj)\n    const groupAllocation = this._getAllocation(flag, airshipObj.getGroup())\n\n    const finalAllocation = this._resolveAllocations(\n      allocation,\n      groupAllocation\n    )\n\n    const expo = this._getExposure(\n      flag,\n      airshipObj,\n      finalAllocation,\n      'get_payload'\n    )\n    this._saveExposure(expo)\n\n    stat.stop()\n    this._saveStat(stat)\n    return finalAllocation.treatment.isGhost\n      ? (flag.offTreatment && flag.offTreatment.payload) || null\n      : finalAllocation.treatment.payload\n  }\n\n  isEligible(flag, obj) {\n    const stat = new Stat('duration__is_eligible', Stat.TYPE_DURATION)\n    stat.start()\n    obj = obj || this.object\n\n    const airshipObj = this._identifyObject(obj)\n    if (!airshipObj.isValid() || flag.isUncategorized()) {\n      return false\n    }\n\n    const allocation = this._getAllocation(flag, airshipObj)\n    const groupAllocation = this._getAllocation(flag, airshipObj.getGroup())\n\n    const finalAllocation = this._resolveAllocations(\n      allocation,\n      groupAllocation\n    )\n\n    const expo = this._getExposure(\n      flag,\n      airshipObj,\n      finalAllocation,\n      'is_eligible'\n    )\n    this._saveExposure(expo)\n\n    stat.stop()\n    this._saveStat(stat)\n    return finalAllocation.eligible\n  }\n\n  isEnabled(flag, obj) {\n    const stat = new Stat('duration__is_enabled', Stat.TYPE_DURATION)\n    stat.start()\n    obj = obj || this.object\n\n    const airshipObj = this._identifyObject(obj)\n    if (!airshipObj.isValid() || flag.isUncategorized()) {\n      return false\n    }\n\n    const allocation = this._getAllocation(flag, airshipObj)\n    const groupAllocation = this._getAllocation(flag, airshipObj.getGroup())\n\n    const finalAllocation = this._resolveAllocations(\n      allocation,\n      groupAllocation\n    )\n\n    const expo = this._getExposure(\n      flag,\n      airshipObj,\n      finalAllocation,\n      'is_enabled'\n    )\n    this._saveExposure(expo)\n\n    stat.stop()\n    this._saveStat(stat)\n    return !finalAllocation.treatment.isOffTreatment\n  }\n}\n","// Based on https://chrisrng.svbtle.com/lru-cache-in-javascript\nclass LRUNode {\n  constructor(key, value) {\n    if (typeof key === 'undefined' || key === null) {\n      throw 'Cannot have an undefined or null key for a LRUNode'\n    }\n    if (typeof value === 'undefined' || value === null) {\n      throw 'Cannot have an undefined or null value for a LRUNode'\n    }\n    this.key = key\n    this.value = value\n    this.prev = null\n    this.next = null\n  }\n}\n\nexport default class LRU {\n  constructor(limit) {\n    this.size = 0\n    if (typeof limit === 'number') {\n      this.limit = limit\n    } else {\n      this.limit = 10\n    }\n    this.map = {}\n    this.head = null\n    this.tail = null\n  }\n\n  setHead(node) {\n    node.next = this.head\n    node.prev = null\n    if (this.head !== null) {\n      this.head.prev = node\n    }\n    this.head = node\n    if (this.tail === null) {\n      this.tail = node\n    }\n    this.size++\n    this.map[node.key] = node\n  }\n\n  set(key, value) {\n    const node = new LRUNode(key, value)\n    if (this.map[key]) {\n      this.map[key].value = node.value\n      this.remove(node.key)\n    } else {\n      if (this.size >= this.limit) {\n        delete this.map[this.tail.key]\n        this.size--\n        this.tail = this.tail.prev\n        this.tail.next = null\n      }\n    }\n    this.setHead(node)\n  }\n\n  get(key) {\n    if (this.map[key]) {\n      const value = this.map[key].value\n      const node = new LRUNode(key, value)\n      this.remove(key)\n      this.setHead(node)\n      return value\n    } else {\n      // console.log('Key ' + key + ' does not exist in the cache.')\n      return null // Return null because null cannot be a LRUNode value\n    }\n  }\n\n  remove(key) {\n    const node = this.map[key]\n    if (node.prev !== null) {\n      node.prev.next = node.next\n    } else {\n      this.head = node.next\n    }\n    if (node.next !== null) {\n      node.next.prev = node.prev\n    } else {\n      this.tail = node.prev\n    }\n    delete this.map[key]\n    this.size--\n  }\n\n  removeAll(limit) {\n    this.size = 0\n    this.map = {}\n    this.head = null\n    this.tail = null\n    if (typeof limit === 'number') {\n      this.limit = limit\n    }\n  }\n\n  forEach(callback) {\n    let node = this.head\n    let i = 0\n    while (node) {\n      callback(node, i)\n      i++\n      node = node.next\n    }\n  }\n}\n","import Flag from './flag'\n\nexport default class Router {\n  constructor(gatingInfo) {\n    this.gatingInfo = gatingInfo\n    this.gatingInfoMap = this._getGatingInfoMap(this.gatingInfo)\n  }\n\n  _getGatingInfoMap(gatingInfo) {\n    const map = {}\n\n    const flags = gatingInfo.flags\n\n    for (let i = 0; i < flags.length; i++) {\n      const flag = Object.assign({}, flags[i])\n      if (flag.flagType === 'uncategorized' || flag.flagStatus === 'archived') {\n        map[flag.codename] = new Flag(flag)\n        continue\n      }\n\n      const overrides = flag.overrides\n      const overridesMap = {}\n\n      for (let j = 0; j < overrides.length; j++) {\n        const override = overrides[j]\n\n        overridesMap[`${override.entityType}_${override.entityId}`] = override\n      }\n\n      flag.overrides = overridesMap\n\n      const treatments = flag.treatments\n      const treatmentsMap = {}\n      let offTreatment = null\n\n      for (let k = 0; k < treatments.length; k++) {\n        const treatment = treatments[k]\n\n        treatmentsMap[treatment.treatmentId] = treatment\n\n        if (treatment.isOffTreatment) {\n          offTreatment = treatment\n        }\n      }\n\n      flag.treatments = treatments\n      flag.treatmentsMap = treatmentsMap\n      flag.offTreatment = offTreatment\n\n      map[flag.codename] = new Flag(flag)\n    }\n\n    return map\n  }\n\n  getIngestionMaxItem() {\n    const sdkInfo = this.gatingInfo.sdkInfo\n    if (sdkInfo) {\n      return sdkInfo.SDK_INGESTION_MAX_ITEMS\n    }\n    return null\n  }\n\n  getBrowserIngestionMaxItems() {\n    const sdkInfo = this.gatingInfo.sdkInfo\n    if (sdkInfo) {\n      return sdkInfo.SDK_BROWSER_INGESTION_MAX_ITEMS\n    }\n    return null\n  }\n\n  getIngestionInterval() {\n    const sdkInfo = this.gatingInfo.sdkInfo\n    if (sdkInfo) {\n      return sdkInfo.SDK_INGESTION_INTERVAL * 1000\n    }\n    return null\n  }\n\n  getBrowserIngestionInterval() {\n    const sdkInfo = this.gatingInfo.sdkInfo\n    if (sdkInfo) {\n      return sdkInfo.SDK_BROWSER_INGESTION_INTERVAL * 1000\n    }\n    return null\n  }\n\n  getShouldIngestObjects() {\n    const sdkInfo = this.gatingInfo.sdkInfo\n    if (sdkInfo && typeof sdkInfo.SDK_SHOULD_INGEST_OBJECTS === 'boolean') {\n      return sdkInfo.SDK_SHOULD_INGEST_OBJECTS\n    }\n    return null\n  }\n\n  getShouldIngestStats() {\n    const sdkInfo = this.gatingInfo.sdkInfo\n    if (sdkInfo && typeof sdkInfo.SDK_SHOULD_INGEST_STATS === 'boolean') {\n      return sdkInfo.SDK_SHOULD_INGEST_STATS\n    }\n    return null\n  }\n\n  getShouldIngestExposures() {\n    const sdkInfo = this.gatingInfo.sdkInfo\n    if (sdkInfo && typeof sdkInfo.SDK_SHOULD_INGEST_EXPOSURES === 'boolean') {\n      return sdkInfo.SDK_SHOULD_INGEST_EXPOSURES\n    }\n    return null\n  }\n\n  getShouldIngestFlags() {\n    const sdkInfo = this.gatingInfo.sdkInfo\n    if (sdkInfo && typeof sdkInfo.SDK_SHOULD_INGEST_FLAGS === 'boolean') {\n      return sdkInfo.SDK_SHOULD_INGEST_FLAGS\n    }\n    return null\n  }\n\n  getFlag(flagName) {\n    return this.gatingInfoMap[flagName] || new Flag(flagName)\n  }\n\n  getEnv() {\n    return this.gatingInfo.env\n  }\n\n  isLocallyConfigured() {\n    return this.getEnv().envKey === null\n  }\n}\n","import EventSource from 'eventsource'\nimport Environment from './environment'\nimport {logger} from './logger'\nimport LRU from './lru'\nimport Router from './router'\nimport Stat from './stat'\nimport {version} from '../package.json'\n\nimport * as http from 'http'\nimport * as https from 'https'\nimport * as URL from 'url'\n\n// Default API domain\nconst DEFAULT_API_DOMAIN = 'airshiphq.com'\n\n// Primary API endpoints\nconst IDENTIFY_ENDPOINT = `/v2/identify`\nconst GATING_INFO_ENDPOINT = `/v2/gating-info`\n\n// SSE API endpoints\nconst SSE_GATING_INFO_ENDPOINT = `/v2/sse-events`\n\n// Backup API URL & endpoint\nconst BACKUP_URL = 'https://backup-api.airshiphq.com'\nconst BACKUP_GATING_INFO_ENDPOINT = `${BACKUP_URL}/v2/gating-info`\n\nconst REQUEST_TIMEOUT = 10 * 1000\n\n// Default ingestion parameters\nconst DEFAULT_INGESTION_INTERVAL = 30\nconst DEFAULT_BROWSER_INGESTION_INTERVAL = 15\nconst DEFAULT_INGESTION_MAX_ITEMS = 500\nconst DEFAULT_BROWSER_INGESTION_MAX_ITEMS = 5\n\nexport default class Airship extends Environment {\n  constructor(gatingInfoListener) {\n    super()\n\n    this.gatingInfoListener = gatingInfoListener\n    this.init()\n  }\n\n  init() {\n    this.ingestionMaxItems = DEFAULT_INGESTION_MAX_ITEMS\n    this.ingestionInterval = DEFAULT_INGESTION_INTERVAL * 1000\n\n    // eslint-disable-next-line no-undef\n    if (__BROWSER__) {\n      this.ingestionMaxItems = DEFAULT_BROWSER_INGESTION_MAX_ITEMS\n      this.ingestionInterval = DEFAULT_BROWSER_INGESTION_INTERVAL * 1000\n    }\n\n    this.objects = []\n    this.stats = []\n    this.exposures = []\n    this.flags = new Set()\n    this.oldFlags = new Set()\n\n    this.objectLRUCache = new LRU(500)\n    this.firstIngestion = true\n\n    this.shouldIngestObjects = true\n    this.shouldIngestStats = true\n    this.shouldIngestExposures = true\n    this.shouldIngestFlags = true\n\n    // this.restartIngestionWorker()\n  }\n\n  restartIngestionWorker() {\n    if (this.ingestionWorker) {\n      clearInterval(this.ingestionWorker)\n    }\n\n    this.ingestionWorker = setInterval(() => {\n      this.maybeIngest(true)\n    }, this.ingestionInterval)\n  }\n\n  async maybeIngest(force = false) {\n    if (!this.shouldIngestObjects) {\n      this.objects = []\n    }\n\n    if (!this.shouldIngestStats) {\n      this.stats = []\n    }\n\n    if (!this.shouldIngestExposures) {\n      this.exposures = []\n    }\n\n    if (!this.shouldIngestFlags) {\n      this.flags = new Set()\n    }\n\n    let shouldIngest =\n      force ||\n      (this.objects.length >= this.ingestionMaxItems ||\n        this.stats.length >= this.ingestionMaxItems ||\n        this.exposures.length >= this.ingestionMaxItems ||\n        this.flags.size > 0)\n\n    if (this.firstIngestion) {\n      shouldIngest = shouldIngest || this.objects.length > 0\n      this.firstIngestion = !shouldIngest\n    }\n\n    if (\n      this.objects.length === 0 &&\n      this.stats.length === 0 &&\n      this.exposures.length === 0 &&\n      this.flags.size === 0\n    ) {\n      shouldIngest = false\n    }\n\n    if (shouldIngest) {\n      const objects = this.objects\n      const stats = this.stats\n      const exposures = this.exposures\n      const flags = Array.from(this.flags)\n      flags.forEach(flagName => {\n        this.oldFlags.add(flagName)\n      })\n\n      this.objects = []\n      this.stats = []\n      this.exposures = []\n      this.flags = new Set()\n\n      await this.postContent(\n        this.primaryServerUrl + IDENTIFY_ENDPOINT + '/' + this.envKey,\n        JSON.stringify({\n          objects: objects,\n          stats: stats.map(s => s.getStatsObj()).filter(so => so !== null),\n          exposures: exposures,\n          flags: flags,\n          sdkInfo: {\n            name: '__SDK_NAME__',\n            version: version\n          }\n        })\n      ).catch(err => {\n        logger(err)\n      })\n    }\n  }\n\n  _identifyObject(obj) {\n    const airshipObj = Environment.prototype._identifyObject.call(this, obj)\n\n    if (!airshipObj.isValid()) {\n      return airshipObj\n    }\n    const id = airshipObj.getId()\n    const hash = airshipObj.getHash()\n    const storedHash = this.objectLRUCache.get(id)\n    if (storedHash === null || hash !== storedHash) {\n      this.objects.push(airshipObj.getRawObject())\n    }\n\n    this.objectLRUCache.set(id, hash)\n    this.maybeIngest()\n\n    return airshipObj\n  }\n\n  _compactStats() {\n    this.stats = Stat.compactStats(this.stats)\n  }\n\n  _saveStat(stat) {\n    this.stats.push(stat)\n    if (this.stats.length >= this.ingestionMaxItems) {\n      this._compactStats()\n    }\n    this.maybeIngest()\n  }\n\n  _saveExposure(expo) {\n    this.exposures.push(expo)\n    this.maybeIngest()\n  }\n\n  async publish(objs) {\n    if (!Array.isArray(objs)) {\n      logger('The \"publish\" method takes an array of objects (aka entities).')\n      return\n    }\n\n    objs.forEach(obj => {\n      this._identifyObject(obj)\n    })\n\n    await this.maybeIngest(true)\n  }\n\n  async getContent(url) {\n    const response = await fetch(url)\n    const contentType = response.headers.get('content-type')\n    if (contentType && contentType === 'application/json') {\n      return response.json().then(data => {\n        // process your JSON data further\n        return data\n      })\n    } else {\n      return response.text().then(text => {\n        // this is text, do something with it\n        return text\n      })\n    }\n  }\n\n  async postContent(url, data, contentType = 'application/json') {\n    const options = {\n      method: 'POST',\n      headers: {\n        'Content-Type': contentType,\n        'Content-Length': Buffer.byteLength(data)\n      },\n      redirect: 'follow',\n      body: data\n    }\n    const response = await fetch(url, options)\n    const responseContentType = response.headers.get('content-type')\n    if (responseContentType && responseContentType === 'application/json') {\n      return response.json().then(data => {\n        // process your JSON data further\n        return data\n      })\n    } else {\n      return response.text().then(text => {\n        // this is text, do something with it\n        return text\n      })\n    }\n  }\n\n  async _getGatingInfo() {\n    const body = await this.getContent(\n      `${this.primaryServerUrl}${GATING_INFO_ENDPOINT}/${\n        this.envKey\n      }?casing=camel`\n    )\n    return body\n  }\n\n  async _getBackupGatingInfo() {\n    const body = await this.getContent(\n      `${BACKUP_GATING_INFO_ENDPOINT}/${this.envKey}-camel`\n    )\n    return body\n  }\n\n  updateSDK() {\n    const ingestionMaxItems = this.router.getIngestionMaxItem()\n    const browserIngestionMaxItems = this.router.getBrowserIngestionMaxItems()\n    const ingestionInterval = this.router.getIngestionInterval()\n    const browserIngestionInterval = this.router.getBrowserIngestionInterval()\n    const shouldIngestObjects = this.router.getShouldIngestObjects()\n    const shouldIngestStats = this.router.getShouldIngestStats()\n    const shouldIngestExposures = this.router.getShouldIngestExposures()\n    const shouldIngestFlags = this.router.getShouldIngestFlags()\n\n    // eslint-disable-next-line no-undef\n    if (__BROWSER__) {\n      // Use SDK info's browserIngestionMaxItems threshold instead (if it exists)\n      if (\n        typeof browserIngestionMaxItems === 'number' &&\n        browserIngestionMaxItems > 0\n      ) {\n        this.ingestionMaxItems = browserIngestionMaxItems\n        this.restartIngestionWorker()\n      }\n\n      // Use SDK info's ingestionInterval instead (if it exists)\n      if (\n        typeof browserIngestionInterval === 'number' &&\n        browserIngestionInterval > 0 &&\n        browserIngestionInterval != this.ingestionInterval\n      ) {\n        this.ingestionInterval = browserIngestionInterval\n        this.restartIngestionWorker()\n      }\n    } else {\n      // Use SDK info's ingestionMaxItem threshold instead (if it exists)\n      if (typeof ingestionMaxItems === 'number' && ingestionMaxItems > 0) {\n        this.ingestionMaxItems = ingestionMaxItems\n        this.restartIngestionWorker()\n      }\n\n      // Use SDK info's ingestionInterval instead (if it exists)\n      if (\n        typeof ingestionInterval === 'number' &&\n        ingestionInterval > 0 &&\n        ingestionInterval != this.ingestionInterval\n      ) {\n        this.ingestionInterval = ingestionInterval\n        this.restartIngestionWorker()\n      }\n    }\n\n    // Check if SDK info directs SDK to ingest entities\n    if (typeof shouldIngestObjects === 'boolean') {\n      this.shouldIngestObjects = shouldIngestObjects\n    }\n\n    // Check if SDK info directs SDK to ingest stats\n    if (typeof shouldIngestStats === 'boolean') {\n      this.shouldIngestStats = shouldIngestStats\n    }\n\n    // Check if SDK info directs SDK to ingest exposures\n    if (typeof shouldIngestExposures === 'boolean') {\n      this.shouldIngestExposures = shouldIngestExposures\n    }\n\n    // Check if SDK info directs SDK to ingest flags\n    if (typeof shouldIngestFlags === 'boolean') {\n      this.shouldIngestFlags = shouldIngestFlags\n    }\n  }\n\n  async updateGatingInfo(statName, fetchFn) {\n    try {\n      const stat = new Stat(statName, Stat.TYPE_DURATION)\n      stat.start()\n      const result = await fetchFn()\n      const gatingInfo = result\n      this.router = new Router(gatingInfo)\n      this.updateSDK()\n      if (this.gatingInfoListener) {\n        this.gatingInfoListener(gatingInfo)\n      }\n      stat.stop()\n      this._saveStat(stat)\n    } catch (err) {\n      console.log(err)\n      logger(err)\n\n      return false\n    }\n    return true\n  }\n\n  async configure(\n    envKey,\n    subscribeToUpdates = true,\n    apiDomain = DEFAULT_API_DOMAIN\n  ) {\n    const envKeyRegex = /^[a-z0-9]{16}$/\n    if (!envKey.match(envKeyRegex)) {\n      throw 'options[\"envKey\"] should be a string of lowercase characters and digits. Double check on the Airship web app.'\n    }\n\n    this.envKey = envKey\n    this.subscribeToUpdates = subscribeToUpdates\n\n    this.primaryServerUrl = `https://api.${apiDomain}`\n    this.sseServerUrl = `https://sse.${apiDomain}`\n\n    this.init()\n\n    this.failed = false\n\n    // First try the Airship server\n    if (\n      !(await this.updateGatingInfo(\n        'duration__gating_info',\n        this._getGatingInfo.bind(this)\n      ))\n    ) {\n      // Then try the Airship CloudFront distribution\n      this.failed = !(await this.updateGatingInfo(\n        'duration__cloudfront_gating_info',\n        this._getBackupGatingInfo.bind(this)\n      ))\n    }\n\n    if (this.failed) {\n      throw 'Failed to retrieve initial gating information'\n    }\n\n    if (subscribeToUpdates) {\n      this._subscribeToUpdates()\n      this._policeSSE()\n    }\n  }\n\n  async shutdown() {\n    if (this.ingestionWorker) {\n      clearInterval(this.ingestionWorker)\n    }\n\n    this._unpoliceSSE()\n    this._unsubscribeFromUpdates()\n\n    await this.maybeIngest(true)\n  }\n\n  flag(flagName) {\n    const flag = Environment.prototype.flag.call(this, flagName)\n    if (flag.isWild()) {\n      // Register the new uncategorized flag\n      if (!this.oldFlags.has(flagName)) {\n        this.flags.add(flagName)\n        this.maybeIngest()\n      }\n    }\n    return flag\n  }\n\n  _policeSSE() {\n    this._unpoliceSSE()\n    this.policeSSEInterval = setInterval(() => {\n      const now = Date.now()\n      const then = this.lastSSEConnectTimestamp || 0\n      if ((now - then) / 1000 > 30) {\n        logger(\n          'Did not receive a keepalive for more than 30 seconds. Reconnecting.'\n        )\n        this._subscribeToUpdates()\n      }\n    }, 5 * 1000)\n\n    this.pollGatingInfoInterval = setInterval(() => {\n      const now = Date.now()\n      const then = this.lastSSEConnectTimestamp || 0\n      if ((now - then) / 1000 > 60) {\n        logger(\n          'Did not receive a keepalive for more than 30 seconds. Polling gating info.'\n        )\n        this.updateGatingInfo(\n          'duration__cloudfront_gating_info',\n          this._getBackupGatingInfo.bind(this)\n        ).then(\n          () => logger('Polled gating info from CloudFront'),\n          () => logger('Failed polling gating info from CloudFront')\n        )\n      }\n    }, 60 * 1000)\n  }\n\n  _unpoliceSSE() {\n    if (this.policeSSEInterval) {\n      clearInterval(this.policeSSEInterval)\n      delete this.policeSSEInterval\n\n      if (this.lastSSEConnectTimestamp) {\n        delete this.lastSSEConnectTimestamp\n      }\n    }\n\n    if (this.pollGatingInfoInterval) {\n      clearInterval(this.pollGatingInfoInterval)\n      delete this.pollGatingInfoInterval\n    }\n  }\n\n  _subscribeToUpdates() {\n    this._unsubscribeFromUpdates()\n\n    this.eventSource = new EventSource(\n      `${this.sseServerUrl}${SSE_GATING_INFO_ENDPOINT}?envkey=${\n        this.envKey\n      }&casing=camel`\n    )\n    this.eventSource.addEventListener('gatingInfoUpdate', evt => {\n      const gatingInfo = JSON.parse(evt.data)\n      this.router = new Router(gatingInfo)\n      this.updateSDK()\n      if (this.gatingInfoListener) {\n        this.gatingInfoListener(gatingInfo)\n      }\n      this.lastSSEConnectTimestamp = Date.now()\n    })\n\n    this.eventSource.addEventListener('keepalive', () => {\n      this.lastSSEConnectTimestamp = Date.now()\n    })\n  }\n\n  _unsubscribeFromUpdates() {\n    if (this.eventSource) {\n      this.eventSource.close()\n      delete this.eventSource\n    }\n  }\n}\n","import {logger} from '../logger'\nimport {isValidFlagConfig} from '../validators/core_validator'\nimport Population, {\n  RULE_TYPE_STRING,\n  RULE_TYPE_INT,\n  RULE_TYPE_FLOAT,\n  RULE_TYPE_BOOLEAN,\n  RULE_TYPE_DATE,\n  RULE_TYPE_DATETIME,\n  RULE_OPERATOR_IS,\n  RULE_OPERATOR_IS_NOT,\n  RULE_OPERATOR_IN,\n  RULE_OPERATOR_NOT_IN,\n  RULE_OPERATOR_LT,\n  RULE_OPERATOR_LTE,\n  RULE_OPERATOR_GT,\n  RULE_OPERATOR_GTE,\n  RULE_OPERATOR_FROM,\n  RULE_OPERATOR_UNTIL,\n  RULE_OPERATOR_AFTER,\n  RULE_OPERATOR_BEFORE\n} from '../population'\n\nconst RULE_TYPE_TO_ALLOWED_OPERATORS = {\n  [RULE_TYPE_STRING]: new Set([\n    RULE_OPERATOR_IS,\n    RULE_OPERATOR_IS_NOT,\n    RULE_OPERATOR_IN,\n    RULE_OPERATOR_NOT_IN\n  ]),\n  [RULE_TYPE_INT]: new Set([\n    RULE_OPERATOR_IS,\n    RULE_OPERATOR_IS_NOT,\n    RULE_OPERATOR_IN,\n    RULE_OPERATOR_NOT_IN,\n    RULE_OPERATOR_LT,\n    RULE_OPERATOR_LTE,\n    RULE_OPERATOR_GT,\n    RULE_OPERATOR_GTE\n  ]),\n  [RULE_TYPE_FLOAT]: new Set([\n    RULE_OPERATOR_IS,\n    RULE_OPERATOR_IS_NOT,\n    RULE_OPERATOR_IN,\n    RULE_OPERATOR_NOT_IN,\n    RULE_OPERATOR_LT,\n    RULE_OPERATOR_LTE,\n    RULE_OPERATOR_GT,\n    RULE_OPERATOR_GTE\n  ]),\n  [RULE_TYPE_BOOLEAN]: new Set([RULE_OPERATOR_IS, RULE_OPERATOR_IS_NOT]),\n  [RULE_TYPE_DATE]: new Set([\n    RULE_OPERATOR_IS,\n    RULE_OPERATOR_IS_NOT,\n    RULE_OPERATOR_IN,\n    RULE_OPERATOR_NOT_IN,\n    RULE_OPERATOR_FROM,\n    RULE_OPERATOR_UNTIL,\n    RULE_OPERATOR_AFTER,\n    RULE_OPERATOR_BEFORE\n  ]),\n  [RULE_TYPE_DATETIME]: new Set([\n    RULE_OPERATOR_IS,\n    RULE_OPERATOR_IS_NOT,\n    RULE_OPERATOR_IN,\n    RULE_OPERATOR_NOT_IN,\n    RULE_OPERATOR_FROM,\n    RULE_OPERATOR_UNTIL,\n    RULE_OPERATOR_AFTER,\n    RULE_OPERATOR_BEFORE\n  ])\n}\n\nexport const transformFlagConfig = flagConfig => {\n  if (!isValidFlagConfig(flagConfig)) {\n    return null\n  }\n\n  const flags = []\n  const keys = Object.keys(flagConfig)\n  for (let i = 0; i < keys.length; i++) {\n    const key = keys[i]\n    const config = flagConfig[key]\n    const active = config.active !== undefined ? config.active : true\n    const flagInfo = {\n      flagType: 'basic',\n      hashKey: key,\n      isPaused: !active,\n      isWebAccessible: __BROWSER__, // eslint-disable-line no-undef\n      codename: key,\n      flagStatus: 'operational'\n    }\n    const whitelist = config.whitelist || []\n    const blacklist = config.blacklist || []\n    const blacklistSet = new Set(blacklist)\n    const filteredWhitelist = whitelist.filter(i => !blacklistSet.has(i))\n\n    flagInfo.treatments = [\n      {\n        treatmentId: 'off-treatment',\n        codename: 'off',\n        isControl: false,\n        isOffTreatment: true\n      },\n      {\n        treatmentId: 'on-treatment',\n        codename: 'on',\n        isControl: false,\n        isOffTreatment: false\n      }\n    ]\n\n    flagInfo.overrides = []\n\n    flagInfo.overrides = flagInfo.overrides.concat(\n      filteredWhitelist.map(i => ({\n        treatmentId: 'on-treatment',\n        entityType: 'User',\n        entityId: i.toString()\n      }))\n    )\n\n    flagInfo.overrides = flagInfo.overrides.concat(\n      blacklist.map(i => ({\n        treatmentId: 'off-treatment',\n        entityType: 'User',\n        entityId: i.toString()\n      }))\n    )\n\n    flagInfo.splits = [{treatmentId: 'on-treatment', percentage: 1}]\n\n    if (config.population) {\n      const rules = config.population || []\n      const ruleInfos = []\n\n      for (let j = 0; j < rules.length; j++) {\n        const r = rules[j]\n        let type\n        if (Array.isArray(r.value)) {\n          const types = new Set(\n            r.value.map(v => Population.categorizeValueType(v))\n          )\n\n          if (types.size != 1) {\n            logger(\n              \"Population's filter criteria each should have a singular value type. In other words, do not mix strings with numbers in the same array, for example.\"\n            )\n            return null\n          }\n\n          type = Array.from(types)[0]\n        } else {\n          type = Population.categorizeValueType(r.value)\n        }\n\n        const rInfo = {\n          attributeName: r.attribute,\n          attributeType: type,\n          operator: r.operator,\n          value: !Array.isArray(r.value) ? r.value : null,\n          valueList: !Array.isArray(r.value) ? null : r.value\n        }\n\n        if (!RULE_TYPE_TO_ALLOWED_OPERATORS[type].has(r.operator)) {\n          logger(\n            `Population's filter operator \\`${\n              r.operator\n            }\\` is not allowed for filter type \\`${type}\\``\n          )\n          return null\n        }\n\n        if (rInfo.valueList) {\n          if (\n            rInfo.operator !== RULE_OPERATOR_IN &&\n            rInfo.operator !== RULE_OPERATOR_NOT_IN\n          ) {\n            logger(\n              \"Population's filter operator must be `in` or `not_in` if the value is an array.\"\n            )\n            return null\n          }\n        } else {\n          if (\n            rInfo.operator === RULE_OPERATOR_IN &&\n            rInfo.operator === RULE_OPERATOR_NOT_IN\n          ) {\n            logger(\n              \"Population's filter operator must not be `in` or `not_in` if the value is a number, boolean or string.\"\n            )\n            return null\n          }\n        }\n\n        ruleInfos.push(rInfo)\n      }\n\n      flagInfo.populations = [\n        {\n          hashKey: 'population-1',\n          entityType: 'User',\n          percentage: config.sample || 0.0,\n          rules: ruleInfos,\n          universes: []\n        }\n      ]\n    } else {\n      flagInfo.populations = [\n        {\n          hashKey: 'population-1',\n          entityType: 'User',\n          percentage: config.sample || 0.0,\n          rules: [],\n          universes: []\n        }\n      ]\n    }\n\n    flags.push(flagInfo)\n  }\n\n  return {\n    flags: flags,\n    env: {\n      hashKey: 'env-1',\n      envKey: null\n    }\n  }\n}\n","import Environment from './environment'\nimport Router from './router'\nimport {transformFlagConfig} from './transformers/core_transformer'\n\nexport default class Core extends Environment {\n  async configure(flagConfig) {\n    const gatingInfo = transformFlagConfig(flagConfig)\n    if (gatingInfo === null) {\n      throw 'Failed to transform flagConfig into initial gating information'\n    }\n    this.router = new Router(gatingInfo)\n  }\n}\n","import {setLogger} from './logger'\nimport Airship from './airship'\nimport Core from './core'\n\nconst defaultEnv = new Core()\ndefaultEnv.configure({})\n\nexport class FlaggerBase {\n  constructor() {\n    this.gatingInfoListeners = []\n  }\n\n  static _isDict(obj) {\n    return obj !== undefined && obj !== null && obj.constructor === Object\n  }\n\n  async publish(objs) {\n    if (this.environment) {\n      await this.environment.publish(objs)\n    } else {\n      throw 'Airship must be configured first before `publish` can be called'\n    }\n  }\n\n  // This will allow for async/await\n  async configure(options) {\n    if (!FlaggerBase._isDict(options)) {\n      throw '<options> must be dictionary'\n    }\n\n    const envKey = options.envKey\n    const flagConfig = options.flagConfig\n\n    if (!envKey && !flagConfig) {\n      throw '<options> must contain envKey corresponding to an environment key or a flagConfig dictionary to configure locally'\n    }\n\n    const subscribeToUpdates =\n      options.subscribeToUpdates === false ? false : true\n\n    if (envKey) {\n      if (\n        this.environment &&\n        this.environment.envKey === envKey &&\n        this.environment.subscribeToUpdates === subscribeToUpdates &&\n        this.environment.environmentPromise &&\n        !this.environment.failed\n      ) {\n        await this.environment.environmentPromise\n      } else {\n        if (this.environment) {\n          await this.environment.shutdown()\n        }\n        this.environment = new Airship(this.handleGatingInfoUpdate.bind(this))\n        const promise = this.environment.configure(\n          envKey,\n          options.subscribeToUpdates,\n          options.apiDomain\n        )\n        this.environment.environmentPromise = promise\n        await promise\n      }\n    } else {\n      if (this.environment) {\n        await this.environment.shutdown()\n      }\n      this.environment = new Core()\n      await this.environment.configure(flagConfig)\n    }\n  }\n\n  async shutdown() {\n    if (this.environment) {\n      await this.environment.shutdown()\n      delete this.environment\n    } else {\n      throw 'Airship must be configured first before `shutdown` can be called'\n    }\n  }\n\n  flag(flagName) {\n    return (this.environment || defaultEnv).flag(flagName)\n  }\n\n  setErrorListener(fn) {\n    setLogger(fn)\n  }\n\n  handleGatingInfoUpdate(gatingInfo) {\n    this.gatingInfoListeners.forEach(listener => listener(gatingInfo))\n  }\n\n  addGatingInfoListener(listener) {\n    this.gatingInfoListeners.push(listener)\n  }\n\n  removeGatingInfoListener(listener) {\n    this.gatingInfoListeners = this.gatingInfoListeners.filter(\n      l => l !== listener\n    )\n  }\n\n  identify(obj) {\n    if (this.environment) {\n      this.environment.identify(obj)\n      this.environment._identifyObject(obj)\n      this.environment.maybeIngest(true)\n    } else {\n      throw 'Airship must be configured first before `identify` can be called'\n    }\n  }\n}\n\nconst Flagger = new FlaggerBase()\n\nexport default Flagger\n","import Airship, {FlaggerBase} from './index'\nObject.assign(Airship, {FlaggerBase})\n\nexport default Airship\n"],"names":["logger","x","console","error","DEFAULT_ENTITY_TYPE","AirshipObject","obj","isValid","isValidObject","_cloneObject","_fillInFields","object","md5","stringify","this","attributes","group","type","id","clone","_Object$assign","isGroup","undefined","groupIndex","lastIndexOf","length","displayName","_Number$isInteger","idStr","RULE_TYPE_STRING","RULE_TYPE_FLOAT","RULE_TYPE_BOOLEAN","RULE_TYPE_DATE","RULE_TYPE_DATETIME","RULE_OPERATOR_IS","RULE_OPERATOR_IS_NOT","RULE_OPERATOR_IN","RULE_OPERATOR_NOT_IN","RULE_OPERATOR_LT","RULE_OPERATOR_LTE","RULE_OPERATOR_GT","RULE_OPERATOR_GTE","RULE_OPERATOR_FROM","RULE_OPERATOR_UNTIL","RULE_OPERATOR_AFTER","RULE_OPERATOR_BEFORE","getHashedValue","s","_parseInt","Population","population","rule","hasOwnProperty","attributeName","v","attributeType","categorizeValueType","numberTypes","indexOf","targetVal","value","targetValList","valueList","op","operator","targetTime","Date","getTime","targetTimeList","map","tv","vTime","env","flag","sticky","entityType","eligible","rules","matches","i","r","_ruleMatches","samplingHashKey","hashKey","hashedPercentage","percentage","splits","universes","Math","max","floor","splitsMap","split","treatmentId","allocationHashKey","allocationHashedPercentage","trailingSum","treatments","filter","t","isOffTreatment","treatment","_parseFloat","toFixed","unixTimestamp","isNaN","isoFormat","toISOString","timeIndex","Stat","name","TYPE_DURATION","TYPE_COUNT","count","startTime","averageDuration","stats","groups","reduce","stat","key","join","push","_Object$values","totalDuration","totalCount","newStat","duration","setAverageDuration","setCount","n","statsObj","unit","Flag","delegate","_isWild","flagName","codename","isPaused","offTreatment","treatmentsMap","overrides","populations","Boolean","flagType","flagStatus","getTreatment","getPayload","isEligible","isEnabled","Environment","objs","router","getFlag","setDelegate","airshipObj","isArchived","getId","override","fromOverride","getRawObject","useUniverses","getType","gateValues","getGateValues","getEnv","alloc1","alloc2","alloc","methodCalled","timeExposed","start","_identifyObject","isUncategorized","allocation","_getAllocation","groupAllocation","getGroup","finalAllocation","_resolveAllocations","expo","_getExposure","_saveExposure","stop","_saveStat","isGhost","payload","LRUNode","prev","next","LRU","limit","size","head","tail","node","remove","setHead","callback","Router","gatingInfo","gatingInfoMap","_getGatingInfoMap","flags","overridesMap","j","entityId","k","sdkInfo","SDK_INGESTION_MAX_ITEMS","SDK_BROWSER_INGESTION_MAX_ITEMS","SDK_INGESTION_INTERVAL","SDK_BROWSER_INGESTION_INTERVAL","SDK_SHOULD_INGEST_OBJECTS","SDK_SHOULD_INGEST_STATS","SDK_SHOULD_INGEST_EXPOSURES","SDK_SHOULD_INGEST_FLAGS","envKey","BACKUP_GATING_INFO_ENDPOINT","Airship","gatingInfoListener","init","ingestionMaxItems","ingestionInterval","DEFAULT_INGESTION_INTERVAL","DEFAULT_BROWSER_INGESTION_INTERVAL","objects","exposures","oldFlags","objectLRUCache","firstIngestion","shouldIngestObjects","shouldIngestStats","shouldIngestExposures","shouldIngestFlags","ingestionWorker","clearInterval","setInterval","_this2","maybeIngest","force","shouldIngest","_Array$from","forEach","_this3","add","postContent","primaryServerUrl","_JSON$stringify","getStatsObj","so","version","catch","err","prototype","call","hash","getHash","storedHash","get","set","compactStats","_compactStats","_Array$isArray","_this4","url","fetch","response","contentType","headers","json","then","data","text","options","method","Buffer","byteLength","redirect","body","responseContentType","getContent","getIngestionMaxItem","browserIngestionMaxItems","getBrowserIngestionMaxItems","browserIngestionInterval","getIngestionInterval","getBrowserIngestionInterval","getShouldIngestObjects","getShouldIngestStats","getShouldIngestExposures","getShouldIngestFlags","restartIngestionWorker","statName","fetchFn","result","updateSDK","log","subscribeToUpdates","apiDomain","envKeyRegex","match","sseServerUrl","failed","updateGatingInfo","_getGatingInfo","bind","_getBackupGatingInfo","_subscribeToUpdates","_policeSSE","_unpoliceSSE","_unsubscribeFromUpdates","isWild","has","policeSSEInterval","_Date$now","_this5","lastSSEConnectTimestamp","pollGatingInfoInterval","eventSource","EventSource","addEventListener","evt","JSON","parse","_this6","close","RULE_TYPE_TO_ALLOWED_OPERATORS","transformFlagConfig","flagConfig","keys","_Object$keys","config","flagInfo","active","isWebAccessible","whitelist","blacklist","blacklistSet","filteredWhitelist","isControl","concat","toString","ruleInfos","types","rInfo","attribute","sample","Core","defaultEnv","configure","FlaggerBase","gatingInfoListeners","environment","publish","_isDict","environmentPromise","shutdown","handleGatingInfoUpdate","promise","fn","listener","l","identify","constructor","Object","Flagger"],"mappings":"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"}